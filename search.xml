<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>dom基础(节点Node类型)</title>
      <link href="2021/06/04/dom%E5%9F%BA%E7%A1%80(%E8%8A%82%E7%82%B9Node%E7%B1%BB%E5%9E%8B)/"/>
      <url>2021/06/04/dom%E5%9F%BA%E7%A1%80(%E8%8A%82%E7%82%B9Node%E7%B1%BB%E5%9E%8B)/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM表示由多层节点构成的文档，通过它可以添加、删除、修改页面各个部分。</p><p>DOM Level 1 在1998年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。</p><p><span style="color: red;font-size:20px">注意</span>    IE8 及更低版本中的 DOM 是通过 COM 对象实现的。 这意味着这些版本的IE中， DOM 对象跟原生 JavaScript 对象具有不同的行为和功能。</p><h2 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h2><p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由<span style="color:yellow">节点</span>构成的层级结构 </p><p>节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系</p><p>例如：</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Sample Page&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p&gt; hello world!&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>层级结构：</p><p><img src="https://raw.githubusercontent.com/DongPangP/myImages/main/Document.png"></p><p>document 节点是每个文档的根节点</p><p>根节点唯一的子节点是 html 元素，被称为 文档元素。 文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内，每个文档只能有一个文档元素。</p><p>HTML 中每段标记都可以表示为这个树形结构中的一个节点。</p><p>元素节点表示HTML元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。</p><p>DOM中总共有12种节点类型，这些类型都继承一种基本类型</p><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>DOM Level 1 描述了名为Node的接口，这个接口是所有 DOM 节点类型必须实现的。</p><p>Node接口在JavaScript中被实现为Node类型，在除IE之外的所有浏览器中都可以直接访问这个类型。</p><p>在JavaScript中，所有节点类型都继承Node类型，因此所有类型都共享相同的基本属性和方法。</p><p>每个节点都有nodeType 属性，表示该节点的类型。节点类型由定义在Node类型上的12个数值常量表示：</p><ul><li>Node.ELEMENT_NODE(1)</li><li>Node.ATTRIBUTE_NODE(2)</li><li>Node.TEXT_NODE(3)</li><li>Node.CDATA_SECTION_NODE(4)</li><li>Node.ENTITY_REFERENCE_NODE(5)</li><li>Node.ENTITY_NODE(6)</li><li>Node.PROCESSING_INSTRUCTION_NODE(7)</li><li>Node.COMMENT_NODE(8)</li><li>Node.DOCUMENT_NODE(9)</li><li>Node.DOCUMENT_TYPE_NODE(10)</li><li>Node.DOCUMENT_FRAGMENT_NODE(11)</li><li>Node.NOTATION_NODE(12)</li></ul><p>节点类型可通过这些常量来比较确定，比如：</p><pre><code>// 比较someNode.nodeType 与 Node.ElEMENT_NODE常量if(someNode.nodeType === Node.ElEMENT_NODE)&#123;    alert(&quot;Node is an element&quot;);&#125;</code></pre><p><span style="color: red;font-size:20px">注意</span>    浏览器并不支持所有节点类型，最常用的是元素节点和文本节点</p><h4 id="nodeName-和-nodeValue"><a href="#nodeName-和-nodeValue" class="headerlink" title="nodeName 和 nodeValue"></a>nodeName 和 nodeValue</h4><p>这两个值保存了节点信息，且取决于节点信息。</p><p>首先检查节点类型</p><pre><code>// 判断节点是否为元素if(someNode.nodeType === 1)&#123;    value = someNode.nodeName;&#125;//对元素而言，nodeName始终等于元素的标签名，而nodeValue则始终为null</code></pre><h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>文档中所有节点和其他节点都有关系，相当于族谱。</p><p>每个节点都有一个childNodes属性，其中包含一个NodeList的实例</p><p><span style="color:yellow">NodeList</span> 是一个类数组对象，用于存储可以按位置存取的有序节点。注意：NodeList 并不是Array的实例，但可以使用中括号访问它的值，而且它也有length属性。NodeList对象独特的地方在于，它其实是一个对DOM结构的查询，因此DOM结构的变化会自动地在NodeLIst反映出来。 NodeList是实时的活动对象，而不是第一次访问所获得内容的快照。</p><p>使用<span style="color:yellow"> Array.prototype.slice()</span> 可以把NodeList对象转换为数组。</p><pre><code>let arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);</code></pre><p>当然，也可以使用 ES6 的 Array.from() 静态方法</p><pre><code>let arrayOfNodes = Array.from(someNode.childNodes);</code></pre><p><img src="https://raw.githubusercontent.com/DongPangP/myImages/main/image-20210604151238225.png" alt="image-20210604151238225"></p><ol><li>每个节点都有一个parentNode属性，指向DOM树中的父元素。childNodes中的所有节点都有同一个父元素，因此它们的parentNode属性指向同一个节点。</li><li>childNodes列表中的每个节点都是同一个列表中其他节点的同胞节点。使用 previousSibling 和 nextSibling 可以在这个列表的节点中进行导航。</li><li>这个列表的第一个节点的 previousSibling 属性是null，最后一个节点的 nextSibling 属性也是 null</li><li>firstChild 和 lastChild 分别指向childNodes的第一个和最后一个，如果只有一个则指向同一个，如果没有则均为null</li><li>可以使用 hasChildNodes() ,返回true，则节点有一个或多个子节点</li><li>最后还有一个所有节点都共享的关系。ownerDocument 属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能存在于两个或多个文档中。</li></ol><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>因为所有关系指针都是只读的，所以DOM提供了一些操作节点的方法：</p><p>appendChild() ：</p><ul><li>​    用于在childNodes 列表<span style="color:yellow">末尾</span>添加节点。</li><li>​    添加新的节点会更新相关的关系指针，包括父节点和之前最后一个子节点。</li><li>​    返回新添加的节点。</li><li>​    如果把已经存在的节点给appenChild()，则调用一次就会出现在末尾。</li></ul><pre><code>let returnedNode = someNode.appendChild(someNode.firstChild);alert(returnedNode == someNode.lastChild);  // truealert(returnedNode == someNode.firstChild); // false</code></pre><p>insertBefore() ：把节点放到childNodes中特定位置而不是末尾</p><pre><code>// 作为最后一个子节点插入returnedNode = someNode.insertBefore(newNode,null);// 作为新的第一个子节点插入returnedNode = someNode.insertBefore(newNode,someNode.firstChild);// 插入到最后一个子节点前面returnedNode = someNode.insertBefore(newNode,someNode.lastChild);</code></pre><p>replaceChild() ：要插入的节点和要替换的节点 ，要替换的节点会被返回并从文档树中移除</p><pre><code>// 替换第一个子节点let returnedNode = someNode.replaceChild(newNode,someNode.firstChild);// 替换最后一个子节点returnedNode = someNode.replaceChild(newNode,someNode.lastChild);</code></pre><p>removeChild() ：移除节点，要删除的节点会被返回并从文档树中移除</p><pre><code>// 删除第一个子节点let formerFirstChild = someNode.removeChild(someNode.firstChild);</code></pre><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>cloneNode()</p><p>该方法接收一个布尔值额。如果传入true，会进行深复制，即复制节点及整个子DOM树；如果传入false，则只会复制调用该方法的节点。</p><p>复制返回的节点属于文档所有，但尚未指定父节点，所以被称为孤儿节点（orphan）</p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;item 1&lt;/li&gt;  &lt;li&gt;item 2&lt;/li&gt;  &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">let deepList = myList.cloneNode(true);alert(deepList.childNodes.length) // 3(IE9之前的版本 或 7 其他浏览器)let shallowList = myList.cloneNode(false);alert(shallowList.childNodes.length) //0</code></pre><p>这个例子中，deepList 保存myList的副本。这意味着 deepList 有3个列表项，每个列表项又各自包含文本。 变量 shallowList 则保存着 myList 的浅副本，因此没有子节点</p><p>注意： cloneNode() 方法不会复制添加到DOM节点的JavaScript属性，比如事件处理程序。这个方法只复制HTML属性，以及可选的复制子节点。除此之外则一概不会复制。IE在很长时间内会复制事件处理程序，这是个bug，所以推荐在复制前先删除事件处理程序。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级程序设计笔记 </category>
          
          <category> Dom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端Excel下载</title>
      <link href="2021/06/03/%E5%89%8D%E7%AB%AFExcel%E4%B8%8B%E8%BD%BD/"/>
      <url>2021/06/03/%E5%89%8D%E7%AB%AFExcel%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><span style="color:red;font-size: 20px">本文借鉴</span> <a href="https://juejin.cn/post/6844903880413675527">纯前端用XLSX库导出excel，可含多个sheet (juejin.cn)</a></p><h2 id="导出逻辑"><a href="#导出逻辑" class="headerlink" title="导出逻辑"></a>导出逻辑</h2><ul><li><p>excel整个表格专业名词是<span style="color:yellow"> workbook</span>，里面每张表格是 <span style="color:yellow">sheet</span></p></li><li><p>页面引入 xlsx 的库 ，<a href="https://unpkg.com/xlsx/dist/xlsx.core.min.js">https://unpkg.com/xlsx/dist/xlsx.core.min.js</a></p></li><li><p>vue中引入xlsx的库</p><pre><code>1、npm install xlsx 2、import XLSX from &#39;xlsx&#39;</code></pre></li><li><p>把数据生成<span style="color:yellow">sheet</span></p><pre><code>var sheet = XLSX.utils.json_to_sheet(jsonData)/* json_to_sheet：将由对象组成的数组转换成sheet   aoa_to_sheet：将由二维数组转换成sheet   table_to_sheet：将table的dom直接转成sheet*/</code></pre></li><li><p>创建虚拟的 <span style="color:yellow">workbook</span></p><pre><code>const wb = XLSX.utils.book_new()</code></pre></li><li><p>把<span style="color:yellow">sheet</span>添加到<span style="color:yellow">workbook</span>里</p><pre><code>XLSX.utils.book_append_sheet(wb, sheet, &quot;这里是sheetName&quot;);</code></pre></li><li><p>把 <span style="color:yellow">workbook</span>转成<span style="color:yellow">blob</span></p><pre><code>const blob = workbook2blob(wb);//看下面的js代码</code></pre></li><li><p>利用a标签和createObjectURl实现下载功能</p><pre><code>openDownloadDialog(blob,&#39;excel的标题.xlsx&#39;);</code></pre></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="js">/** * 生成表格 */import XLSX from &#39;xlsx&#39;;// 将workbook转换成blob对象function workbook2blob(data) &#123;  // 生成excel的配置项  const wopts = &#123;    // 要生成的文件类型    bookType: &#39;xlsx&#39;,    // 是否生成Shared String Table，    // 官方解释时，如果开启生成速度会降低，但在低版本IOS设备上有更好的兼容性    bookSST: false,    type: &#39;binary&#39;  &#125;  const wbout = XLSX.write(data, wopts);  // 将字符串转 ArrayBuffer  function s2ab(s) &#123;    const buf = new ArrayBuffer(s.length);    const view = new Uint8Array(buf);    for (let i = 0; i !== s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff;    return buf;  &#125;  const blob = new Blob([s2ab(wbout)], &#123;    type: &#39;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;&#39;  &#125;);  return blob;&#125; // 将blob对象创建bloburl，然后用a标签实现弹出下载框 function openDownloadDialog(blob, fileName) &#123;  if (typeof blob === &#39;object&#39; &amp;&amp; blob instanceof Blob) &#123;    blob = URL.createObjectURL(blob); // 创建blob地址  &#125;  const aLink = document.createElement(&#39;a&#39;);  aLink.href = blob;  // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，有时候 file:///模式下不会生效  aLink.download = fileName || &#39;&#39;;  let event;  if (window.MouseEvent) &#123;    event = new MouseEvent(&#39;click&#39;);  &#125; else &#123; //   移动端    event = document.createEvent(&#39;MouseEvents&#39;);    event.initMouseEvent(&#39;click&#39;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);  &#125;  aLink.dispatchEvent(event);&#125;export default&#123;  workbook2blob,  openDownloadDialog&#125;</code></pre><pre><code class="js"> /**  * 转换下载ip数据  */async generateAndDownload() &#123;  try&#123;    const info = await this.getIpInfoAll();        const data = info.data.response.data;        if(data.length &gt; 0) &#123;        const sheetData = [];        for(let i = 0, len = data.length; i &lt; len; i++) &#123;           for(let j = 0, len = this.Category.length; j &lt; len; j++) &#123;            if(data[i].EquipmentCategory === this.Category[j].value) &#123;              data[i].EquipmentCategory = this.Category[j].label;              break;            &#125;          &#125;          const obj = &#123;             名称: data[i].EquipmentName,             IP地址: data[i].IPaddr,             Mac地址: data[i].MacAddr,             类型: data[i].EquipmentCategory,             备注: data[i].Note           &#125;           sheetData.push(obj);         &#125;         const sheet = XLSX.utils.json_to_sheet(sheetData);         /* create a new blank workbook */         const wb = XLSX.utils.book_new();         XLSX.utils.book_append_sheet(wb, sheet, &#39;IP信息&#39;);      const workbookBlob = generate.workbook2blob(wb);         generate.openDownloadDialog(workbookBlob, &#39;IP信息&#39;);    &#125;catch(err)&#123;      this.$message.error(&#39;下载出错！&#39;);    &#125;    &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> 拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> xlsx库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
