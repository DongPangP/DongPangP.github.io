<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>变量</title>
      <link href="2021/06/09/%E5%8F%98%E9%87%8F/"/>
      <url>2021/06/09/%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript 变量 可以用于保存任何数据类型。</p><p>有三个关键字：var、const、let ，其中 var 在 ECMAScript 所有版本均可使用，而 const 和 let 只能在ECMAScript 6 及更晚版本中使用。</p><hr><h3 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a>var 关键字</h3><p>定义变量可以使用 var 操作符（var是关键字），后面跟变量名（即标识符）：</p><pre><code>var message; </code></pre><p>定义了一个名为 message 的变量，可以用于保存任何类型的值（不初始化的情况下，会保存一个特殊值 undefined）</p><pre><code>var message=&quot;hello&quot;;</code></pre><p>这里保存了一个 hello 字符串，像这样初始化变量不会将它标识为字符串类型，只是简单的赋值。之后可以更改保存的值，也可以更改值的类型。例如</p><pre><code>var message = &quot;hello&quot;;message = 100;             //合法，但不推荐这么做</code></pre><h4 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h4><p>使用 var 操作符定义的变量，会成为它的函数的局部变量。</p><p>比如，使用var在一个函数内部定义一个变量，就意味着改变量将在函数退出时销毁。</p><pre><code>function test()&#123;    var mes = &quot;hello&quot;;  //局部变量&#125;test();console.log(mes);  // 报错！！！</code></pre><p>但是在函数中定义变量时，<span style="color:yellow">省略var操作符，可以创建一个全局变量</span>。</p><pre><code>function test()&#123;     mes = &quot;hello&quot;;  // 全局变量&#125;test();console.log(mes);  // hello</code></pre><p>只需要调用一次就会创建这个变量，可以在函数外部访问到。</p><p><span style="color:red">注意：</span> 虽然可以这么操作但是不建议这么定义全局变量，这样代码很难维护。且在严格模式下这么给未声明的变量赋值，则会导致抛出ReferenceError</p><p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：</p><pre><code>var message = &quot;hello&quot;,      found = &quot;false&quot;,      age = 18;</code></pre><p>因为 ECMAScript 是松散类型，所以使用不同数据类型初始化的变量可以用一条语句来声明。插入换行和空格缩进不是必需的，但这样有利于阅读。</p><p><span style="color:red">注意：</span>在严格模式下，不能定义名为eval和arguments的变量，否则会导致语法错误</p><h4 id="var声明提升"><a href="#var声明提升" class="headerlink" title="var声明提升"></a>var声明提升</h4><p>使用var时，下面代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域的顶部：</p><pre><code>function foo()&#123;    console.log(age);    var age = 26;&#125;foo(); // undefined</code></pre><p>之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：</p><pre><code>function foo()&#123;    var age;    console.log(age);    age = 26;&#125;foo(); //undefined</code></pre><p>这就是所谓的 “提升”，也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用var声明同一变量也没有关系：</p><pre><code>function foo()&#123;    var age = 16;    var age = 26;    var age = 36;    console.log(age);&#125;foo(); // 36</code></pre><hr><h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><p>let声明的范围是有块作用域的，var声明的范围只有全局作用域和函数作用域。</p><pre><code>if(true)&#123;    var name = &quot;tom&quot;;    console.log(name); // tom&#125;console.log(name); // tomif(true)&#123;    let name = &quot;tom&quot;;    console.log(name); // tom&#125;console.log(name); // ReferenceError: age 没有定义</code></pre><p>块作用域是函数作用域的子集，因此适用于var的作用域限制同样也适用于let。</p><p>let不允许同一个块作用域中出现冗余声明。</p><pre><code>var name;var name;let age;let age; // SyntaxError; 标识符age已经声明过了</code></pre><p>JavaScript引擎会记录用于变量声明的标识符及其所在的作用域，因此嵌套使用相同的标识符不会报错。</p><pre><code>var name = &quot;tom&quot;;console.log(name); // tomif(true)&#123;    var name = &quot;jerry&quot;;    console.log(name); // jerry&#125;let num = 16;console.log(num); //16if(true) &#123;    let num = 26;    console.log(num); //26&#125;</code></pre><p>两个关键字声明的并不是不同类型的变量，而是指出变量在相关作用域如何存在。</p><pre><code>var name;let name; //SyntaxErrorlet age;var age; //SyntaxError</code></pre><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>let声明的变量不会在作用域中提升</p><pre><code>console.log(age); // ReferenceError: age 没有定义let age = 16;</code></pre><p>在解析代码前，JavaScript 引擎也会注意到出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。</p><p>在let 声明之前执行瞬间被称为 “暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出 ReferenceError</p><h4 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h4><p>使用 var 声明的全局变量会成为 window 对象属性，使用 let 声明的则不会。</p><pre><code>var name = &quot;tom&quot;;console.log(window.name); // tomlet age = 26;console.log(window.age); // undefined</code></pre><p>但是 let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。</p><p>因此，为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p><h4 id="条件声明"><a href="#条件声明" class="headerlink" title="条件声明"></a>条件声明</h4><p>使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。=&gt; 所以可以用var声明多个同名变量</p><p>因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它</p><pre><code>&lt;script&gt;    var name = &quot;tom&quot;;    let age = 26;&lt;/script&gt;&lt;script&gt;    // 假设脚本不确定页面中是否已经声明了同名变量    // 那它可以假设还没有声明过        var name = &quot;jerry&quot;;    // 这里没有问题，因为可以被作为一个提升声明来处理    // 不需要检查之前是否声明过同名变量        let age = 36；    // 如果age之前声明过，这里会报错&lt;/script&gt;</code></pre><p>使用 try/catch 语句 或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。</p><p>let 不能依赖于条件声明模式。</p><h4 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h4><p>使用 var ，for循环定义的迭代变量会渗透到循环体外部。</p><pre><code>for(var i=0 ; i&lt;5 ; ++i)&#123;    //循环逻辑&#125;console.log(i); // 5</code></pre><p>使用 let ，这个问题就消失了，因为迭代变量的作用域仅限于for循环内部：</p><pre><code>for(let i=0 ; i&lt;5 ; ++i)&#123;    //循环逻辑&#125;console.log(i); // ReferenceError: i没有定义</code></pre><pre><code>for(var i=0 ; i&lt;5; ++i)&#123;    setTimeout(()=&gt;console.log(i),0);&#125;//实际输出 5、5、5、5、5</code></pre><p>var 在 for 循环中定义的变量 i 没有块级作用域，全局只有一个 i，setTimeout方法执行时 for循环就已经执行完了。所以得到的结果均为 5</p><p>而使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以可以输出我们所期望的值。这个每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环。</p><hr><h3 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h3><p>const 的行为和 let 基本相同，唯一重要的点是用 const 声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p><pre><code>const age = 26;age = 16;         //TypeError: 给常量赋值// const 也不允许重复声明const name = &quot;tom&quot;;const name = &quot;jerry&quot;;  // SyntaxError// const 声明的作用域也是块const name = &quot;tom&quot;;if(true) &#123;    const name = &quot;jerry&quot;;&#125;console.log(name); // tom</code></pre><p>const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。</p><pre><code>const person = &#123;&#125;;person.name = &quot;tom&quot;;</code></pre><p>javaScript 引擎会为 for 循环中的let声明分别创建独立的变量实例，虽然 const变量会跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）。</p><pre><code>for(const i = 0;i&lt;5;++i)&#123;&#125; // TypeError: 给常量赋值</code></pre><p>不过，如果你只想用 const 声明一个不会被修改的for循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。</p><pre><code>let i = 0;for (const j=7;i&lt;5;++i)&#123;    console.log(j);&#125;// 7,7,7,7,7for (const key in &#123;a: 1,b: 2&#125;)&#123;    console.log(key);&#125;// a,bfor (const value of [1,2,3,4,5])&#123;    console.log(value);&#125;// 1,2,3,4,5</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级程序设计笔记 </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dom基础_Document类型</title>
      <link href="2021/06/05/dom%E5%9F%BA%E7%A1%80_Document%E7%B1%BB%E5%9E%8B/"/>
      <url>2021/06/05/dom%E5%9F%BA%E7%A1%80_Document%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>Document 类型是 JavaScript 中表示文档节点的类型。</li><li>在浏览器中，文档对象 document 是HTMLDocument 的实例 （HTMLDocument 继承 Document），表示整个HTML页面</li><li>document 是 window 对象的属性。</li></ol><p>特征：</p><ul><li>nodeType 等于 9；</li><li>nodeName 值为 ‘#document’ ；</li><li>nodeValue 值为 null；</li><li>parentNode 值为 null；</li><li>ownerDocument 值为 null；</li><li>子节点可以为DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction 或 Comment 类型</li></ul><p>Document 类型可以表示 HTML 页面或其他 XML 文档，但最常用的还是通过HTMLDocument的实例取得 document对象。</p><p>document对象可以获取关于页面的信息以及操作其外观和底层结构。</p><h2 id="文档子节点"><a href="#文档子节点" class="headerlink" title="文档子节点"></a>文档子节点</h2><h3 id="documentElement"><a href="#documentElement" class="headerlink" title="documentElement"></a>documentElement</h3><p>documentElement 属性，始终指向HTML页面的 html 元素。虽然 document.childNodes 中始终有 html 元素，但使用 documentElement 属性可以更快更直接的访问该元素。</p><pre><code class="html">&lt;html&gt;  &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>documentElement、firstChild 和 childNodes[0]</p><pre><code class="js">let html = document.documentElement; //取得对&lt;html&gt;的引用alert(html === document.childNodes[0]);  //truealert(html === document.firstChild);  //true</code></pre><h3 id="body"><a href="#body" class="headerlink" title="body"></a>body</h3><p>作为HTMLDocument 的实例，document 对象还有一个body 属性，直接指向 body 元素。</p><pre><code>let body = document.body;</code></pre><p>所有主流浏览器都支持  document.documentElement 和 document.body</p><h3 id="doctype"><a href="#doctype" class="headerlink" title="doctype"></a>doctype</h3><p>Document 类型另一种可能的子节点是 DocumentType。</p><pre><code>&lt;!doctype&gt;标签是文档中独立的部分，其信息可以通过 doctype 属性来访问let doctype = document.doctype; //取得对&lt;!doctype&gt;的引用</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>html 元素外的注释也是文档的子节点，它们的类型是Comment。但是浏览器不同实现不同，这些注释不一定被识别，或者表现不一致。</p><p>这个页面有3个子节点：注释、html元素、注释，但是实际上不同浏览器可能会不一样</p><pre><code class="html">&lt;!-- 第一条注释 --&gt;&lt;html&gt;  &lt;body&gt;      &lt;/body&gt;&lt;/html&gt;&lt;!-- 第二条注释 --&gt;</code></pre><p>另外，一般来说 appendChild()、removeChild()和 replaceChild() 方法不会用在 document 对象上。因为文档类型（如果存在）是只读的，而且只能有一个Element类型的子节点</p><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><ol><li>包含 title 元素中的文本，通常显示在浏览器窗口或标签页的标题栏。</li><li>通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。</li><li>不过，修改title属性并不会改变 title 元素</li></ol><pre><code>// 读取文档标题let originalTitle = document.title;// 修改文档标题document.title = &quot;New page title&quot;;</code></pre><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL包含当前页面完整的URL（地址栏中的URL）</p><pre><code>let url = document.URL;</code></pre><h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>domian 包含当前的域名</p><pre><code>let domain = document.domain;</code></pre><p>domain 可以设置，但是只能设置 URL 中包含的值。</p><pre><code>// 页面来自 p2p.wrox.comdocument.domain = &quot;wrox.com&quot;; //成功document.domain = &quot;aaa.com&quot;; //失败</code></pre><p>当页面中包含来自某个不同子域的窗格（frame）或内嵌窗格（iframe）时，设置document.domain是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过JavaScript通信。此时只要将每个页面上的document.domain设置为相同的值，这些页面就可以访问对方的JavaScript对象了。</p><p>浏览器对domain属性设置只能放松不能收紧</p><h3 id="referrer"><a href="#referrer" class="headerlink" title="referrer"></a>referrer</h3><p>包含链接到当前页面的那个页面的URL，如果当前页面没有来源，则referrer属性包含空字符串</p><pre><code>let refferrer = document.referrer</code></pre><h2 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h2><h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h3><ol><li>接收一个参数，即要返回元素的ID，如果找到了则返回这个元素，如果没找到则返回null。</li><li>参数必须和元素在页面中的id属性值完全匹配，包括大小写。</li><li>如果页面存在多个具有相同ID的元素，则方法只返回文档中出现的第一个元素</li></ol><pre><code>&lt;div id=&quot;myDiv&quot;&gt;hello&lt;/div&gt;let div = document.getElementById(&quot;myDiv&quot;) // 取得对这个&lt;div&gt;元素的引用</code></pre><h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName()"></a>getElementsByTagName()</h3><ol><li>接收一个参数，要获取元素的标签名，返回包含零个或多个元素的 NodeList</li><li>在HTML文档中，这个方法返回一个HTMLCollection对象。考虑到两者都是“实时”列表，HTMLCollection 与 NodeLIst 是很相似的。</li><li>可以通过传入 * 获取文档的所有元素</li></ol><pre><code>let images = document.getElementsByTagName(&quot;img&quot;);</code></pre><p>这里把返回的 HTMLCollection 对象保存在了变量 images 中，与NodeList一样，也可以使用 中括号 或 item() 方法从HTMLCollection 取得特定的元素。</p><pre><code>alert(images.length);alert(images[0].src);alert(images.item(0).src);</code></pre><p>HTMLCollection 对象还有一个额外的方法 namedItem()，可通过标签的 name 属性取得某一项的引用。</p><pre><code>&lt;img src=&quot;my.jpg&quot; name=&quot;myImage&quot;&gt;</code></pre><pre><code>let images = document.getElementsByTagName(&quot;img&quot;);let myImage1 = images.namedItem(&quot;myImage&quot;);let myImage2 = images[&quot;myImage&quot;];</code></pre><h3 id="getElementByName"><a href="#getElementByName" class="headerlink" title="getElementByName()"></a>getElementByName()</h3><p>这个方法会返回具有给定 name 属性的所有元素，最常用于单选按钮</p><h2 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h2><ul><li>document.anchors：包含文档中所有带name属性的 a 元素</li><li>document.forms：包含文档中所有 from 元素</li><li>document.images：包含文档中中所有 img 元素</li><li>document.links：包含文档中所有带href属性的 a 元素</li></ul><h2 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h2><ul><li>write()</li><li>writeIn()</li><li>open()</li><li>close()</li></ul><p>该内容可参考以下文章：</p><p><a href="https://blog.csdn.net/m0_37589327/article/details/78992784">https://blog.csdn.net/m0_37589327/article/details/78992784</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级程序设计笔记 </category>
          
          <category> Dom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伪数组</title>
      <link href="2021/06/05/%E4%BC%AA%E6%95%B0%E7%BB%84/"/>
      <url>2021/06/05/%E4%BC%AA%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="伪数组的特点"><a href="#伪数组的特点" class="headerlink" title="伪数组的特点"></a>伪数组的特点</h2><ul><li>Object 对象</li><li>length 属性</li><li>数值下标属性</li><li>没有数组特别的方法：forEach() ，push()，pop()，splice()</li></ul><pre><code class="js">const obj = &#123;      0: tom,      1: jerry,      2: bob      length: 3&#125;</code></pre><h2 id="如何判断一个对象是否属于伪数组"><a href="#如何判断一个对象是否属于伪数组" class="headerlink" title="如何判断一个对象是否属于伪数组"></a>如何判断一个对象是否属于伪数组</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><pre><code>console.log(Array.isArray(obj)) // false;</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><pre><code>console.log(obj instanceof Array) //false</code></pre><h2 id="常见的伪数组"><a href="#常见的伪数组" class="headerlink" title="常见的伪数组"></a>常见的伪数组</h2><ol><li>jQuery 对象（比如 $(“div”)）</li><li>函数内部的arguments</li><li>DOM中 NodeList对象</li></ol><h2 id="将伪数组转换成数组"><a href="#将伪数组转换成数组" class="headerlink" title="将伪数组转换成数组"></a>将伪数组转换成数组</h2><p>可以使用Array.prototype.slice.call() 将数组转化为真正的Array对象</p><pre><code>const arr = Array.prototype.slice.call(obj);</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级程序设计笔记 </category>
          
          <category> 对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery</title>
      <link href="2021/06/05/jQuery/"/>
      <url>2021/06/05/jQuery/</url>
      
        <content type="html"><![CDATA[<h2 id="如何使用jQuery？"><a href="#如何使用jQuery？" class="headerlink" title="如何使用jQuery？"></a>如何使用jQuery？</h2><h3 id="下载jQuery库"><a href="#下载jQuery库" class="headerlink" title="下载jQuery库"></a>下载jQuery库</h3><p>下载地址：<a href="http://code.jquery.com/">http://code.jquery.com/</a></p><h3 id="引入下载的jQuery库"><a href="#引入下载的jQuery库" class="headerlink" title="引入下载的jQuery库"></a>引入下载的jQuery库</h3><pre><code>&lt;script src=&quot;code/js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="编写jQuery代码"><a href="#编写jQuery代码" class="headerlink" title="编写jQuery代码"></a>编写jQuery代码</h3><pre><code>// 原生JS的固定写法window.onload = function(ev)&#123;&#125;// jQuery的固定写法$(document).ready(function()&#123;   ...&#125;);</code></pre><h3 id="jQuery版本区别"><a href="#jQuery版本区别" class="headerlink" title="jQuery版本区别"></a>jQuery版本区别</h3><p>1.x ：兼容ie678，但相对其他版本文件较大，官方只做BUG维护，功能不再新增，最终版本：1.12.4（2016年5月20日）</p><p>2.x：不兼容ie678，相对1.x文件较小，官方只做BUG维护，功能不再新增，最终版本：2.2.4（2016年5月20日）</p><p>3.x：不兼容ie678，只支持最新的浏览器，很多老的jQuery插件不支持这个版本，相对1.x文件较小，提供不包含ajax/动画API版本</p><h2 id="jQuery入口函数"><a href="#jQuery入口函数" class="headerlink" title="jQuery入口函数"></a>jQuery入口函数</h2><h3 id="jQuery与原生js加载模式的区别"><a href="#jQuery与原生js加载模式的区别" class="headerlink" title="jQuery与原生js加载模式的区别"></a>jQuery与原生js加载模式的区别</h3><h4 id="加载内容不同"><a href="#加载内容不同" class="headerlink" title="加载内容不同"></a>加载内容不同</h4><p>​    原生js会在dom原生与图片内容都加载后执行；</p><p>​    jQuery会在dom元素加载后执行，不会等待图片加载。</p><h4 id="多个入口文件时执行方式不同"><a href="#多个入口文件时执行方式不同" class="headerlink" title="多个入口文件时执行方式不同"></a>多个入口文件时执行方式不同</h4><p>​    原生js只执行最后一个入口文件的内容，即后面的会覆盖前面的；</p><p>​    jQuery多个都执行，前面的执行完才执行后面的</p><h3 id="jQuery入口函数的写法"><a href="#jQuery入口函数的写法" class="headerlink" title="jQuery入口函数的写法"></a>jQuery入口函数的写法</h3><pre><code>$(document).ready(function()&#123;    ...&#125;);jQuery(document).ready(function()&#123;    ...&#125;);$(function()&#123; ...&#125;);</code></pre><h3 id="jQuery冲突问题"><a href="#jQuery冲突问题" class="headerlink" title="jQuery冲突问题"></a>jQuery冲突问题</h3><p>​    当引入多个js文件后，发生 $ 符号重复冲突时</p><p>​    解决方法1：释放 $ 的使用权</p><p>​    注意点：释放操作必须在编写其他 jQuery 代码之前；释放之后不能再使用 $，改为使用 jQuery</p><pre><code>jQuery.noConflict();  //释放操作jQuery(function()&#123;    alert(&#39;hello world&#39;);&#125;);</code></pre><p>​    解决方法2：自定义一个访问符号</p><pre><code>var mmp = jQuery.noConflict();mmp(function()&#123;    alert(&#39;hello mmp&#39;);&#125;);</code></pre><h2 id="jQuery核心函数"><a href="#jQuery核心函数" class="headerlink" title="jQuery核心函数"></a>jQuery核心函数</h2><p>$(); 就代表调用 jQuery 的核心函数</p><pre><code class="js">// 1、接收一个函数$(function ()&#123;  //2、接收一个字符串  //2.1、接收一个字符串选择器,返回一个jQuery对象，对象中保存了找到的DOM对象  var $box1 = $(&quot;.box1&quot;);  var $box2 = $(&quot;#box2&quot;);  //2.2、接收一个字符串代码片段,返回一个jQuery对象,对象保存了DOM元素  var $p = $(&quot;&lt;p&gt;我是段落&lt;/p&gt;&quot;);  $box1.append($p);  // 3、接收一个DOM元素，返回一个jQuery对象  var span = document.getElementByTagName(&quot;span&quot;)[0];  var $span = $(span);  console.log($span);&#125;);</code></pre><h2 id="jQuery-静态方法"><a href="#jQuery-静态方法" class="headerlink" title="jQuery 静态方法"></a>jQuery 静态方法</h2><h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><p>用于遍历指定的对象和数组，即可以遍历伪数组</p><p>each方法 遍历谁就返回谁</p><pre><code>$.each( object,callback );// 举例 index 索引 value 值$(function()&#123;    $.each([23,32],function(index,value)&#123;        alert(index+&#39;:&#39;+value);    &#125;)&#125;);</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>描述：将一个数组中的所有元素转换到另一个数组中</p><p>jQuery.map(array,callback(elementOfArray,indexInArray))</p><p>array ：数组 </p><p>callback(elementOfArray,indexInArray)：处理每一个元素的函数。第一个参数是数组元素，第二个参数是该元素的索引值。该函数可以返回任何值，在函数内部，this将是全局window对象</p><p>jQuery.map(arrayOrObject,callback(value,indexOrKey))</p><p>arrayOrObject：待转换数组或对象</p><p>callback(value,indexOrKey)：处理每一个元素的函数。第一个参数是数组中或对象的值，第二个参数就是该元素在数组中的索引值或该对象的键。该函数可以返回任何值，该返回值会被添加到数组中。若返回时数组，则会将该数组中的元素添加到最终的结果数组中，在函数内部，this将是全局window对象</p><p><strong>在jQuery 1.6之前，</strong><code>$.map()</code>只支持遍历<em>数组和类似数组的对象</em> 。<strong>在jQuery 1.6</strong>也支持遍历对象。</p><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>去除字符串前后空格</p><pre><code>var str = &quot;  ls  &quot;;var res = $.trim(str);console.log(&quot;---&quot;+str+&quot;---&quot;);console.log(&quot;---&quot;+res+&quot;---&quot;);</code></pre><h3 id="isWindow"><a href="#isWindow" class="headerlink" title="isWindow"></a>isWindow</h3><p>判断传入的对象是否是window对象</p><p>返回值：true/false</p><h3 id="isArray"><a href="#isArray" class="headerlink" title="isArray"></a>isArray</h3><p>判断传入的对象是否为数组</p><p>返回值：true/false</p><h3 id="isFunction"><a href="#isFunction" class="headerlink" title="isFunction"></a>isFunction</h3><p>判断传入的对象是否为函数</p><p>返回值：true/false</p><p>jQuery是一个函数</p><h3 id="holdReady"><a href="#holdReady" class="headerlink" title="holdReady"></a>holdReady</h3><p>$.holdReady(true);  作用：暂停ready执行</p><p>$.holdReady(false); 作用：恢复执行</p><pre><code>$.holdReady(true); $(document).ready(function()&#123;    alert(&quot;ready&quot;);&#125;);</code></pre><h2 id="jQuery内容选择器"><a href="#jQuery内容选择器" class="headerlink" title="jQuery内容选择器"></a>jQuery内容选择器</h2><pre><code class="html">&lt;div&gt;&lt;/div&gt;&lt;div&gt;  我是div&lt;/div&gt;&lt;div&gt;  &lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><h3 id="empty"><a href="#empty" class="headerlink" title=":empty"></a>:empty</h3><p>作用：找到既没有文本内容也没有子元素的指定元素</p><pre><code>var $div = $(&quot;div:empty&quot;);</code></pre><h3 id="parent"><a href="#parent" class="headerlink" title=":parent"></a>:parent</h3><p>作用：找到有文本内容或有子元素的指定元素</p><pre><code>var $div = $(&quot;div:parent&quot;);</code></pre><h3 id="contains"><a href="#contains" class="headerlink" title=":contains"></a>:contains</h3><p>作用：找到包含指定文本内容的指定元素</p><pre><code>var $div = $(&quot;div:contains(&#39;我是div&#39;)&quot;);</code></pre><h3 id="has"><a href="#has" class="headerlink" title=":has"></a>:has</h3><p>作用：找到包含指定子元素的指定元素</p><pre><code>var $div = $(&quot;div:has(&#39;span&#39;)&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dom基础_节点Node类型</title>
      <link href="2021/06/04/dom%E5%9F%BA%E7%A1%80_%E8%8A%82%E7%82%B9Node%E7%B1%BB%E5%9E%8B/"/>
      <url>2021/06/04/dom%E5%9F%BA%E7%A1%80_%E8%8A%82%E7%82%B9Node%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM表示由多层节点构成的文档，通过它可以添加、删除、修改页面各个部分。</p><p>DOM Level 1 在1998年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。</p><p><span style="color: red;font-size:20px">注意</span>    IE8 及更低版本中的 DOM 是通过 COM 对象实现的。 这意味着这些版本的IE中， DOM 对象跟原生 JavaScript 对象具有不同的行为和功能。</p><h2 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h2><p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由<span style="color:yellow">节点</span>构成的层级结构 </p><p>节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系</p><p>例如：</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Sample Page&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p&gt; hello world!&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>层级结构：</p><p><img src="https://raw.githubusercontent.com/DongPangP/myImages/main/Document.png"></p><p>document 节点是每个文档的根节点</p><p>根节点唯一的子节点是 html 元素，被称为 文档元素。 文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内，每个文档只能有一个文档元素。</p><p>HTML 中每段标记都可以表示为这个树形结构中的一个节点。</p><p>元素节点表示HTML元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。</p><p>DOM中总共有12种节点类型，这些类型都继承一种基本类型</p><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>DOM Level 1 描述了名为Node的接口，这个接口是所有 DOM 节点类型必须实现的。</p><p>Node接口在JavaScript中被实现为Node类型，在除IE之外的所有浏览器中都可以直接访问这个类型。</p><p>在JavaScript中，所有节点类型都继承Node类型，因此所有类型都共享相同的基本属性和方法。</p><p>每个节点都有nodeType 属性，表示该节点的类型。节点类型由定义在Node类型上的12个数值常量表示：</p><ul><li>Node.ELEMENT_NODE(1)</li><li>Node.ATTRIBUTE_NODE(2)</li><li>Node.TEXT_NODE(3)</li><li>Node.CDATA_SECTION_NODE(4)</li><li>Node.ENTITY_REFERENCE_NODE(5)</li><li>Node.ENTITY_NODE(6)</li><li>Node.PROCESSING_INSTRUCTION_NODE(7)</li><li>Node.COMMENT_NODE(8)</li><li>Node.DOCUMENT_NODE(9)</li><li>Node.DOCUMENT_TYPE_NODE(10)</li><li>Node.DOCUMENT_FRAGMENT_NODE(11)</li><li>Node.NOTATION_NODE(12)</li></ul><p>节点类型可通过这些常量来比较确定，比如：</p><pre><code>// 比较someNode.nodeType 与 Node.ElEMENT_NODE常量if(someNode.nodeType === Node.ElEMENT_NODE)&#123;    alert(&quot;Node is an element&quot;);&#125;</code></pre><p><span style="color: red;font-size:20px">注意</span>    浏览器并不支持所有节点类型，最常用的是元素节点和文本节点</p><h4 id="nodeName-和-nodeValue"><a href="#nodeName-和-nodeValue" class="headerlink" title="nodeName 和 nodeValue"></a>nodeName 和 nodeValue</h4><p>这两个值保存了节点信息，且取决于节点信息。</p><p>首先检查节点类型</p><pre><code>// 判断节点是否为元素if(someNode.nodeType === 1)&#123;    value = someNode.nodeName;&#125;//对元素而言，nodeName始终等于元素的标签名，而nodeValue则始终为null</code></pre><h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>文档中所有节点和其他节点都有关系，相当于族谱。</p><p>每个节点都有一个childNodes属性，其中包含一个NodeList的实例</p><p><span style="color:yellow">NodeList</span> 是一个类数组对象，用于存储可以按位置存取的有序节点。注意：NodeList 并不是Array的实例，但可以使用中括号访问它的值，而且它也有length属性。NodeList对象独特的地方在于，它其实是一个对DOM结构的查询，因此DOM结构的变化会自动地在NodeLIst反映出来。 NodeList是实时的活动对象，而不是第一次访问所获得内容的快照。</p><p>使用<span style="color:yellow"> Array.prototype.slice()</span> 可以把NodeList对象转换为数组。</p><pre><code>let arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);</code></pre><p>当然，也可以使用 ES6 的 Array.from() 静态方法</p><pre><code>let arrayOfNodes = Array.from(someNode.childNodes);</code></pre><p><img src="https://raw.githubusercontent.com/DongPangP/myImages/main/image-20210604151238225.png" alt="image-20210604151238225"></p><ol><li>每个节点都有一个parentNode属性，指向DOM树中的父元素。childNodes中的所有节点都有同一个父元素，因此它们的parentNode属性指向同一个节点。</li><li>childNodes列表中的每个节点都是同一个列表中其他节点的同胞节点。使用 previousSibling 和 nextSibling 可以在这个列表的节点中进行导航。</li><li>这个列表的第一个节点的 previousSibling 属性是null，最后一个节点的 nextSibling 属性也是 null</li><li>firstChild 和 lastChild 分别指向childNodes的第一个和最后一个，如果只有一个则指向同一个，如果没有则均为null</li><li>可以使用 hasChildNodes() ,返回true，则节点有一个或多个子节点</li><li>最后还有一个所有节点都共享的关系。ownerDocument 属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能存在于两个或多个文档中。</li></ol><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>因为所有关系指针都是只读的，所以DOM提供了一些操作节点的方法：</p><p>appendChild() ：</p><ul><li>​    用于在childNodes 列表<span style="color:yellow">末尾</span>添加节点。</li><li>​    添加新的节点会更新相关的关系指针，包括父节点和之前最后一个子节点。</li><li>​    返回新添加的节点。</li><li>​    如果把已经存在的节点给appenChild()，则调用一次就会出现在末尾。</li></ul><pre><code>let returnedNode = someNode.appendChild(someNode.firstChild);alert(returnedNode == someNode.lastChild);  // truealert(returnedNode == someNode.firstChild); // false</code></pre><p>insertBefore() ：把节点放到childNodes中特定位置而不是末尾</p><pre><code>// 作为最后一个子节点插入returnedNode = someNode.insertBefore(newNode,null);// 作为新的第一个子节点插入returnedNode = someNode.insertBefore(newNode,someNode.firstChild);// 插入到最后一个子节点前面returnedNode = someNode.insertBefore(newNode,someNode.lastChild);</code></pre><p>replaceChild() ：要插入的节点和要替换的节点 ，要替换的节点会被返回并从文档树中移除</p><pre><code>// 替换第一个子节点let returnedNode = someNode.replaceChild(newNode,someNode.firstChild);// 替换最后一个子节点returnedNode = someNode.replaceChild(newNode,someNode.lastChild);</code></pre><p>removeChild() ：移除节点，要删除的节点会被返回并从文档树中移除</p><pre><code>// 删除第一个子节点let formerFirstChild = someNode.removeChild(someNode.firstChild);</code></pre><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>cloneNode()</p><p>该方法接收一个布尔值额。如果传入true，会进行深复制，即复制节点及整个子DOM树；如果传入false，则只会复制调用该方法的节点。</p><p>复制返回的节点属于文档所有，但尚未指定父节点，所以被称为孤儿节点（orphan）</p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;item 1&lt;/li&gt;  &lt;li&gt;item 2&lt;/li&gt;  &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">let deepList = myList.cloneNode(true);alert(deepList.childNodes.length) // 3(IE9之前的版本 或 7 其他浏览器)let shallowList = myList.cloneNode(false);alert(shallowList.childNodes.length) //0</code></pre><p>这个例子中，deepList 保存myList的副本。这意味着 deepList 有3个列表项，每个列表项又各自包含文本。 变量 shallowList 则保存着 myList 的浅副本，因此没有子节点</p><p>注意： cloneNode() 方法不会复制添加到DOM节点的JavaScript属性，比如事件处理程序。这个方法只复制HTML属性，以及可选的复制子节点。除此之外则一概不会复制。IE在很长时间内会复制事件处理程序，这是个bug，所以推荐在复制前先删除事件处理程序。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript高级程序设计笔记 </category>
          
          <category> Dom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端Excel下载</title>
      <link href="2021/06/03/%E5%89%8D%E7%AB%AFExcel%E4%B8%8B%E8%BD%BD/"/>
      <url>2021/06/03/%E5%89%8D%E7%AB%AFExcel%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><span style="color:red;font-size: 20px">本文借鉴</span> <a href="https://juejin.cn/post/6844903880413675527">纯前端用XLSX库导出excel，可含多个sheet (juejin.cn)</a></p><h2 id="导出逻辑"><a href="#导出逻辑" class="headerlink" title="导出逻辑"></a>导出逻辑</h2><ul><li><p>excel整个表格专业名词是<span style="color:yellow"> workbook</span>，里面每张表格是 <span style="color:yellow">sheet</span></p></li><li><p>页面引入 xlsx 的库 ，<a href="https://unpkg.com/xlsx/dist/xlsx.core.min.js">https://unpkg.com/xlsx/dist/xlsx.core.min.js</a></p></li><li><p>vue中引入xlsx的库</p><pre><code>1、npm install xlsx 2、import XLSX from &#39;xlsx&#39;</code></pre></li><li><p>把数据生成<span style="color:yellow">sheet</span></p><pre><code>var sheet = XLSX.utils.json_to_sheet(jsonData)/* json_to_sheet：将由对象组成的数组转换成sheet   aoa_to_sheet：将由二维数组转换成sheet   table_to_sheet：将table的dom直接转成sheet*/</code></pre></li><li><p>创建虚拟的 <span style="color:yellow">workbook</span></p><pre><code>const wb = XLSX.utils.book_new()</code></pre></li><li><p>把<span style="color:yellow">sheet</span>添加到<span style="color:yellow">workbook</span>里</p><pre><code>XLSX.utils.book_append_sheet(wb, sheet, &quot;这里是sheetName&quot;);</code></pre></li><li><p>把 <span style="color:yellow">workbook</span>转成<span style="color:yellow">blob</span></p><pre><code>const blob = workbook2blob(wb);//看下面的js代码</code></pre></li><li><p>利用a标签和createObjectURl实现下载功能</p><pre><code>openDownloadDialog(blob,&#39;excel的标题.xlsx&#39;);</code></pre></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="js">/** * 生成表格 */import XLSX from &#39;xlsx&#39;;// 将workbook转换成blob对象function workbook2blob(data) &#123;  // 生成excel的配置项  const wopts = &#123;    // 要生成的文件类型    bookType: &#39;xlsx&#39;,    // 是否生成Shared String Table，    // 官方解释时，如果开启生成速度会降低，但在低版本IOS设备上有更好的兼容性    bookSST: false,    type: &#39;binary&#39;  &#125;  const wbout = XLSX.write(data, wopts);  // 将字符串转 ArrayBuffer  function s2ab(s) &#123;    const buf = new ArrayBuffer(s.length);    const view = new Uint8Array(buf);    for (let i = 0; i !== s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff;    return buf;  &#125;  const blob = new Blob([s2ab(wbout)], &#123;    type: &#39;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;&#39;  &#125;);  return blob;&#125; // 将blob对象创建bloburl，然后用a标签实现弹出下载框 function openDownloadDialog(blob, fileName) &#123;  if (typeof blob === &#39;object&#39; &amp;&amp; blob instanceof Blob) &#123;    blob = URL.createObjectURL(blob); // 创建blob地址  &#125;  const aLink = document.createElement(&#39;a&#39;);  aLink.href = blob;  // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，有时候 file:///模式下不会生效  aLink.download = fileName || &#39;&#39;;  let event;  if (window.MouseEvent) &#123;    event = new MouseEvent(&#39;click&#39;);  &#125; else &#123; //   移动端    event = document.createEvent(&#39;MouseEvents&#39;);    event.initMouseEvent(&#39;click&#39;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);  &#125;  aLink.dispatchEvent(event);&#125;export default&#123;  workbook2blob,  openDownloadDialog&#125;</code></pre><pre><code class="js"> /**  * 转换下载ip数据  */async generateAndDownload() &#123;  try&#123;    const info = await this.getIpInfoAll();        const data = info.data.response.data;        if(data.length &gt; 0) &#123;        const sheetData = [];        for(let i = 0, len = data.length; i &lt; len; i++) &#123;           for(let j = 0, len = this.Category.length; j &lt; len; j++) &#123;            if(data[i].EquipmentCategory === this.Category[j].value) &#123;              data[i].EquipmentCategory = this.Category[j].label;              break;            &#125;          &#125;          const obj = &#123;             名称: data[i].EquipmentName,             IP地址: data[i].IPaddr,             Mac地址: data[i].MacAddr,             类型: data[i].EquipmentCategory,             备注: data[i].Note           &#125;           sheetData.push(obj);         &#125;         const sheet = XLSX.utils.json_to_sheet(sheetData);         /* create a new blank workbook */         const wb = XLSX.utils.book_new();         XLSX.utils.book_append_sheet(wb, sheet, &#39;IP信息&#39;);      const workbookBlob = generate.workbook2blob(wb);         generate.openDownloadDialog(workbookBlob, &#39;IP信息&#39;);    &#125;catch(err)&#123;      this.$message.error(&#39;下载出错！&#39;);    &#125;    &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> 拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> xlsx库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
