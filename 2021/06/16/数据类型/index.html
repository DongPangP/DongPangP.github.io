<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>数据类型 | 穆飘</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="穆飘" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">穆飘</a></h1></div><p class="m-desc">别想太多，学就完事了！！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">数据类型</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2021/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">2021-06-16</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/">JavaScript高级程序设计笔记</a>&nbsp;&bull;&nbsp;<a href="/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a></span></div></div><div class="p-content"><p>ECMAScript 有6种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。（Symbol 符号 是ECMAScript6新增的）</p>
<p>1种复杂数据类型 Object（对象）：Object 是一种无序名值对的集合</p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。</p>
<p>对一个值使用 typeof 操作符会返回下列字符串之一：</p>
<ul>
<li>undefined  表示值未定义；</li>
<li>boolean     表示值为布尔值；</li>
<li>string         表示值为字符串；</li>
<li>number      表示值为数值；</li>
<li>object         表示值为对象（而不是函数）或 null；</li>
<li>function      表示值为函数；</li>
<li>symbol       表示值为符号；</li>
</ul>
<p>缺点：</p>
<ol>
<li>不能判断变量具体的数据类型，比如数组、正则、日期对象，因为都会返回Object ，不过可以判断 function。</li>
<li>判断 null 的时候会返回 Object ；判断 NaN 的时候返回 number </li>
</ol>
<p>注意：</p>
<p>严格来说，函数在ECMAScript 中被认定为<span style="color:pink">对象</span>,并不代表一种数据类型，可以使用 typeof 来区分函数和其他对象</p>
<h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>Undefined 只有一个值，就是特殊值 undefined 。</p>
<p>当使用 let 或 var 声明变量但没有初始化时，就相当于给变量赋予了 undefined 值</p>
<pre><code>let mes;
console.log(mes == undefined); // true

let name; //这个变量被声明了，只是值为undefined
//确保没有声明过这个变量
//let age;

console.log(name); //undefined
console.log(age);  //报错
</code></pre>
<p>无论是否声明的变量，使用typeof均返回 undefined</p>
<pre><code>let name; //这个变量被声明了，只是值为undefined
//确保没有声明过这个变量
//let age;

console.log(typeof name); //undefined
console.log(typeof age);  //undefined
</code></pre>
<p>因为声明变量或未声明变量，使用typeof检测都会得到undefined。所以在声明变量的时候应该直接初始化，这样可以使用typeof检测哪些给定变量未进行声明。</p>
<p>undefined 是一个假值。</p>
<pre><code>let message;  // 这个变量被声明了，只是值为undefined
if(message)&#123;
    // 不会执行
&#125;
if(!message)&#123;
    // 会执行
&#125;
if(age)&#123;
    // age没有声明直接报错
&#125;
</code></pre>
<h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>Null 类型同样只有一个值，即特殊值 null。 null值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 object 的原因。</p>
<pre><code>let car = null;
console.log(typeof car); //object
</code></pre>
<p>在定义将要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否之后赋予了一个对象的引用。</p>
<pre><code>if(car != null)&#123;
    // car是一个对象的引用
&#125;
</code></pre>
<p>undefined 值由 null 派生而来，因此 ECMA-262 将它们定义为表面相等，例如：</p>
<pre><code>console.log(null == undefined); // true
</code></pre>
<p>用操作符（==）比较 null 和 undefined 始终返回 true，但是这个操作符会为了比较而转换它的操作数。</p>
<p>undefined 不能显示的用于变量值的设置，但是 null 需要显示的进行使用。任何时候，只要变量保存对象，而当时又没有对象可以保存，则需要使用 null 进行填充。</p>
<p>null 是一个假值</p>
<pre><code>let message = null;
let age;
if(message)&#123;
    // 不会执行
&#125;
if(!message)&#123;
    // 执行
&#125;
if(age)&#123;
    // 判断 undefined 不会执行
&#125;
if(!age)&#123;
    // 判断 undefined 会执行
&#125;
</code></pre>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>Boolean(布尔值)类型是ECMAScript中使用最频繁的类型之一，有两个字面值：true 和 false</p>
<p>注意：<span style="color:yellow">true和false区分大小写</span></p>
<p>虽然布尔值只有两个，但所有其他ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的<span   style="color:yellow">Boolean()</span>转型函数：</p>
<pre><code>let message = &quot;Hello World&quot;;
let bool = Boolean(message);
</code></pre>
<p>Boolean() 转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。转换规则：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true</th>
<th>转换为false</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>非空字符串</td>
<td>“”(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>非零数值（包括无穷值）</td>
<td>0、NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任意对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>不存在</td>
<td>undefined</td>
</tr>
</tbody></table>
<p>像 if 等流控制语句会自动执行其他类型值到布尔值的转换。</p>
<pre><code>let message = &quot;hello world&quot;;
if(message)&#123;
    console.log(&quot;true&quot;);
&#125;
</code></pre>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Number 表示整数和浮点数。不同的数值类型相应的也有不同的数值字面量格式。</p>
<p>最基本数值字面量是十进制整数：</p>
<pre><code>let num1 = 233;
</code></pre>
<p>整数也可以使用八进制和十六进制。八进制字面量第一个值必须是零（0），然后是相应的八进制数（0-7），如果字面量中包含了数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当做十进制数。</p>
<pre><code>let octalNum1 = 070;  // 56
let octalNum2 = 079;  //当作79处理
let octalNum3 = 08;   //当作8处理
</code></pre>
<p>八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。（严格模式下，前缀0被视为语法错误，需要使用前缀0o）</p>
<p>十六进制字面量，前缀0x，然后是十六进制数。十六进制数大小写均可：</p>
<pre><code>let hexNum1 = 0xA;  // 10
let hexNum2 = 0x1f; // 31
</code></pre>
<p>注意：</p>
<p>由于JavaScript保存数值的方式，实际上可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>要定义浮点数，数值中必须包含小数点，而且小数点后必须至少有一个数字。虽然小数点前不是必须有整数，但是推荐加上。</p>
<pre><code>let floatNum1 = 2.33;
let floatNum2 = 0.2;
let floatNum3 = .6;  //有效但不推荐
</code></pre>
<p>因为存储浮点数使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法的将值转换为整数。在小数点后没有数字的情况，数值会转换为整数。</p>
<pre><code>let floatNum1 = 1.; //小数点后没有数字，当成整数1处理
let floatNum2 = 10.0; //小数点后面是零，当成整数10处理
</code></pre>
<p>对于非常大或者非常小的值，可以使用科学计数法</p>
<pre><code>let floatNum1 = 3.125e7; //31250000
let floatNum2 = 3e-17;  //0.000 000 000 000 000 03
</code></pre>
<p>浮点数的精确度最高可达17位小数，但是算术计算中远不如整数精确。例如：0.1加0.2得到的不是0.3，而是0.300 000 000 000 000 04</p>
<pre><code>// 所以不要判断浮点数
if(a + b == 0.3) &#123;
    console.log(&quot;you got 0.3&quot;);
&#125;
</code></pre>
<p>这里检测的两个数值之和是否等于0.3。如果两个数值分别是0.05和0.25，或者0.15和0.15，那没问题。但如果是0.1和0.2，则判断不成功。之所以存在这种舍入错误，是因为使用了IEEE 754 数值。</p>
<h3 id="值的范围"><a href="#值的范围" class="headerlink" title="值的范围"></a>值的范围</h3><p>最小值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e-324</p>
<p>最大值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308</p>
<p>Infinity 正无穷大；-Infinity 负无穷大</p>
<p>要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用 isFinite() 函数</p>
<pre><code>let result = Number.MAX_VALUE + Number.MAX_VALUE;
console.log(isFinite(result));  //false
</code></pre>
<p>Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 分别表示 -Infinity 和 Infinity</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>有一个特殊值叫 NaN，意思是 “不是数值” （Not a Number）,用于表示本来要返回数值的操作失败了（而不是抛出错误）。</p>
<p>比如，用 0 除任意数值在其他语言中通常会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0、-0相除会返回NaN：</p>
<pre><code>console.log(0/0); // NaN
console.log(-0/+0); // NaN
</code></pre>
<p>如果分子是非 0 值，分母是有符号0 或无符号 0，则会返回 Infinity 或 -Infinity:</p>
<pre><code>console.log(5/0) ; //Infinity
console.log(5/-0); //-Infinity
</code></pre>
<ul>
<li>任何涉及NaN的操作始终会返回NaN（如NaN/10）</li>
<li>NaN不等于包括NaN在内的任何值</li>
</ul>
<p>ECMAScript 提供了<span style= "color:yellow"> isNaN()</span>。该函数接收任意数据类型，然后判断这个参数是否（不是数值）。把一个数值传给 isNaN() 后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换为数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致整个函数返回 true</p>
<pre><code>console.log(isNaN(NaN)); //true
console.log(isNaN(10));  //false
console.log(isNaN(&quot;10&quot;)); //false
console.log(isNaN(&quot;blue&quot;)); //true
console.log(isNaN(true)); //false
</code></pre>
<p>注意：虽然不常见，但 isNaN() 可以用于测试对象。此时，首先会调用对象的 valueOf() 方法，然后再确认返回的值是否可以转换为数值。如果不能，再调用 toString() 方法，并测试其返回值。这通常时 ECMAScript 内置函数和操作符的工作方式。</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p>有 3 个函数可以将非数值转换为数值：<span style="color:yellow">Number() </span>、<span style="color:yellow">parseInt()</span> 和<span style="color:yellow"> parseFloat()</span></p>
<p>Number() 是转型函数，可用于任何数据类型。后面两个主要用于字符串转换为数值。</p>
<h4 id="Number-1"><a href="#Number-1" class="headerlink" title="Number()"></a>Number()</h4><p>Number() 基于以下规则进行转换：</p>
<ul>
<li><p>布尔值，true 转换为 1 ，false 转换为 0</p>
</li>
<li><p>数值，直接返回</p>
</li>
<li><p>null，返回0</p>
</li>
<li><p>undefined，返回 NaN</p>
</li>
<li><p>字符串，应用以下规则</p>
<p>1、如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”) 返回1，Number(“123”) 返回123，     Number(“011”) 返回11（忽略前面的零）</p>
<p>2、如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）</p>
<p>3、如果字符串包含有效的十六进制格式如 “0xf”，则会转换为与该十六进制对应的十进制整数值。</p>
<p>4、如果是空字符串（不包含字符），则返回0</p>
<p>5、如果字符串包含除上述情况之外的其他字符，则返回 NaN</p>
</li>
<li><p>对象，调用 valueOf() 方法，并按照上述规则转换返回的值。如果转换结果是NaN，则调用 toString() 方法，并按照转换字符串的规则转换。</p>
</li>
</ul>
<pre><code>let num1 = Number(&quot;hello123&quot;); //NaN
let num2 = Number(&quot;&quot;);         //0
let num3 = number(&quot;0xff&quot;);     //255
</code></pre>
<h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>考虑到使用 Number() 函数转换字符串时相对复杂且优点反常规，通常在需要得到整数时可以优先使用 parseInt() 函数。</p>
<p>parseInt() 函数更专注于字符串是否包含数值模式。</p>
<ul>
<li>字符串最前面的空格会被忽略，从第一个非空字符开始转换。如果第一个字符不是数值字符、加号或减号，立即返回 NaN。</li>
</ul>
<pre><code>let num1 = parseInt(&quot;&quot;);         // NaN
let num2 = parseInt(&quot; 234&quot;);       //234
let num3 = parseInt(&quot;hello234&quot;); // NaN
</code></pre>
<ul>
<li>如果第一个字符时数值字符、加号或减号，则继续依次检测每个字符，知道字符串末尾，或碰到非数值字符串</li>
</ul>
<pre><code>let num4 = parseInt(&quot;1234hello&quot;); // 1234
let num5 = parseInt(&quot;22.5&quot;);      // 22
let num6 = parseInt(&quot;0xA&quot;);       // 10
</code></pre>
<ul>
<li>不同的数值格式容易混淆，因此 parseInt() 也接收第二个参数，用于指定进制数</li>
</ul>
<pre><code>let num7 = parseInt(&quot;AF&quot;,16);  // 175
let num8 = parseInt(&quot;AF&quot;);         // NaN
let num9 = parseInt(&quot;10&quot;, 2);   // 2,按二进制进行解析
let num10 = parseInt(&quot;10&quot;, 8);  // 8,按八进制进行解析
let num11 = parseInt(&quot;10&quot;, 10);  // 10,按十进制进行解析
let num12 = parseInt(&quot;10&quot;, 16);  // 16,按十六进制进行解析
</code></pre>
<h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><p>parseFloat() 函数的工作方式和 parseInt() 类似。</p>
<p>区别：</p>
<ul>
<li>它也是解析到字符串末尾或者解析到一个无效的浮点数值字符位置。这意味着第一次出现的小数点是有效的，但第二次出现就无效了，此时字符串剩余的字符会被忽略。因此 “2.33.33” 将转换为 2.33</li>
<li>它始终忽略字符串开头的零。整个函数能识别前面讨论的说有浮点格式，以及十进制格式（开头的零始终忽略）。</li>
<li>十六进制数值始终会返回 0 ，因为parseFloat()只解析十进制，因此不能指定底数。</li>
<li>如果字符串表示为整数，则返回整数</li>
</ul>
<pre><code>let num1 = parseFloat(&quot;1234blue&quot;); //1234
let num2 = parseFloat(&quot;0xA&quot;);      //0
let num3 = parseFloat(&quot;0908.5&quot;);   //908.5
let num4 = parseFloat(&quot;3.125e7&quot;);  //31250000
</code></pre>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p><strong>Symbol(符号)</strong>是 ECMAScript6 新增的数据类型。符号是原始值，且符号实例唯一、不可变。<span style="color:yellow">用于确保对象属性使用唯一标识符，不会发生属性冲突的危险。</span></p>
<h3 id="Symbol的基本用法"><a href="#Symbol的基本用法" class="headerlink" title="Symbol的基本用法"></a>Symbol的基本用法</h3><p>Symbol 需要使用 Symbol() 函数初始化。 因为 Symbol 本身是原始类型，所以 typeof 操作符对 Symbol 返回 Symbol</p>
<pre><code>let sym = Symbol();
console.log(typeof sym); //Symbol
</code></pre>
<p>调用 Symbol() 函数时，也可以传入一个字符串参数作为对符号的描述 (description) ，将来可以通过整个字符串来调试代码。但是，这个字符串参数与符号定义和标识完全无关。</p>
<pre><code>let one = Symbol(&#39;ann&#39;);
let two = Symbol(&#39;ann&#39;);
console.log(one == two);  // false
</code></pre>
<p>Symbol没有字面量语法，所以按照规范只要创建Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性。</p>
<pre><code>let name = &quot;tom&quot; ; //字面量语法
// Symbol没有这种语法，只能通过Symbol()
let age = Symbol();
</code></pre>
<p>Symbol() 函数不能与new关键字一起作为构造函数使用</p>
<pre><code>let myBool = new Boolean();
console.log(typeof myBool); // object

let myString = new String();
console.log(typeof myString); // object

let myNumber = new Number();
console.log(typeof myNumber); //object

let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor

//如果你确实想使用符号包装对象，可以借用Object()函数
let mySymbol2 = Symbol();
let myWrappedSymbol = Object(mySymbol2);
console.log(typeof myWrappedSymbol); //object
</code></pre>
<h3 id="使用全局符号注册表"><a href="#使用全局符号注册表" class="headerlink" title="使用全局符号注册表"></a>使用全局符号注册表</h3><p>如果运行时的不同部分需要共享和重用Symbol实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用Symbol。</p>
<p><span style="color:yellow">Symbol.for()</span>对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p>
<pre><code>let fooGlobalSymbol = Symbol.for(&quot;foo&quot;);
let other = Symbol.for(&quot;foo&quot;);
console.log(fooGlobalSymbol === other); //true
</code></pre>
<p>即使采用相同的描述，在全局注册表中定义的符号跟使用Symbol()定义的符号也并不相同。</p>
<pre><code>let localSymbol = Symbol(&quot;tom&quot;);
let globalSymbol = Symbol.for(&quot;tom&quot;);
console.log(localSymbol === globalSymbol);
</code></pre>
<p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给 Symbol.for()的任何值都会被转换为字符串。注册表中使用的键也会被用作Symbol描述。</p>
<pre><code>let emptySymbol = Symbol.for();
console.log(emptySymbol); // Symbol(undefined)
</code></pre>
<p>可以使用<span style="color:yellow">Symbol.keyFor()</span>来查询全局注册表，接收Symbol，返回该全局符号对应的字符串键</p>
<pre><code>//创建全局符号
let s = Symbol.for(&quot;tom&quot;);
console.log(Symbol.keyFor(s)); &quot;tom&quot;

//创建普通符号
let s2 = Symbol(&quot;tom&quot;);
console.log(Symbol.keyFor(s2)); //undefined

//如果传给keyFor的不是符号
Symbol.keyFor(&quot;123&quot;);  //TypeError: 123 is not Symbol
</code></pre>
<h3 id="使用符号作为属性"><a href="#使用符号作为属性" class="headerlink" title="使用符号作为属性"></a>使用符号作为属性</h3><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties() 定义的属性。</p>
<p>对象字面量属性只能在计算属性语法中使用符号作为属性：</p>
<pre><code>let s1 = Symbol(&quot;a&quot;),
      s2 = Symbol(&quot;b&quot;),
    s3 = Symbol(&quot;c&quot;),
    s4 = Symbol(&quot;d&quot;),

let o = &#123;
    [s1]: &quot;a val&quot;
&#125;

Object.defineProperty(o,s2,&#123;value: &#39;b val&#39;&#125;);

Object.defineProperties(o,&#123;
    [s3]: &#123;value: &quot;c val&quot;&#125;,
    [s4]: &#123;value: &quot;d val&quot;&#125;
&#125;)
</code></pre>
<ul>
<li>Object.getOwnPropertyNames() 返回对象实例的常规属性数组</li>
<li>Object.getOwnPropertySymbols() 返回对象实例的符号属性数组</li>
<li>Object.getOwnPropertyDescriptors() 返回同时包含常规和符号属性描述符的对象</li>
<li>Reflect.ownKeys() 返回两种类型的键</li>
</ul>
<pre><code>let s1 = Symbol(&#39;foo&#39;),
      s2 = Symbol(&#39;bar&#39;);
let o = &#123;
    [s1]: &#39;foo val&#39;,
    [s2]: &#39;bar val&#39;,
    baz: &#39;baz val&#39;,
    qux: &#39;qux val&#39;
&#125;

console.log(Object.getOwnPropertySymbols(o));
//[Symbol(foo),Symbol(bar)]

console.log(Object.getOwnPropertyNames(o));
//[&quot;baz&quot;,&quot;qux&quot;]

console.log(Object.getOwnPropertyDescriptors(o));
//&#123;baz: &#123;...&#125;,qux:&#123;...&#125;,Symbol(foo):&#123;...&#125;,Symbol(bar):&#123;...&#125;&#125;

console.log(Reflect.ownKeys(o));
//[&quot;baz&quot;,&quot;qux&quot;,Symbol(foo),Symbol(bar)]
</code></pre>
<p>因为符号属性是对内存符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显示的保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键。</p>
<pre><code>let o = &#123;
    [Symbol(&#39;foo&#39;)]: &#39;foo val&#39;,
    [Symbol(&#39;bar&#39;)]: &#39;bar val&#39;
&#125;
let barSymbol = Object.getOwnPropertySymbols(o).find(symbol =&gt; symbol.toString().match(/bar/));
console.log(barSymbol); // Symbol(bar)
</code></pre>
<h3 id="常用内置符号"><a href="#常用内置符号" class="headerlink" title="常用内置符号"></a>常用内置符号</h3><p>ECMAScript 也引入了一批常用内置符号，用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。</p>
<p>在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为 @@。 比如@@Iterator 指的就是 Symbol.iterator</p>
<h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过new操作符后跟对象类型的名称来创建。</p>
<pre><code>// 先通过创建Object类型的实例来创建自己的对象，然后再给对象添加属性和方法
let obj = new Object();

// 如果没有参数可以省略括号（不推荐）
let obj2 = new Object;
</code></pre>
<p>类似Java中的 java.lang.Object，ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p>
<p>每个Object实例都有以下属性和方法：</p>
<ul>
<li>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object() 函数</li>
<li>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如o.hasOwnProperty(“name”)）或符号。</li>
<li>isPrototypeOf(object)：用于判断当前对象是否是另一个对象的原型</li>
<li>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用 for-in 语句枚举。与hasOwnProperty()一样，属性名必须是字符串。</li>
<li>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li>
<li>toString()：返回对象的字符串表示</li>
<li>valueOf()：返回对象相应的字符串、数值或布尔值表示。通常与 toString() 的返回值相同</li>
</ul>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。</p>
<p>字符串可以使用双引号(“)、单引号(‘)、反引号(`)。</p>
<h3 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h3><p>ECMAScript中的字符串是不可变的，即一旦创建，要修改某个变量中的字符串的值，必须先销毁原始字符串，然后将包含新值的另一个字符串保存到该变量中。如下所示：</p>
<pre><code>let lang = &quot;Java&quot;;
lang = lang + &quot;Script&quot;;
</code></pre>
<p>整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上 “Java” 和 “Script”，最后销毁原始的字符串 “Java” 和 “Script”</p>
<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p><span style="color:yellow">toString()</span>返回当前值的字符串等价物。可用于数值、布尔值、对象和字符串值（字符串值也有toString()方法，该方法只是简单的返回自身的一个副本），null和undefined 值没有 toString() 方法。</p>
<p>toString()可以接收参数，将数值转换为二进制、八进制、十六进制数的字符串</p>
<pre><code>let num = 10;
console.log(num.toString()); // &quot;10&quot;
console.log(num.toString(2)); // &quot;1010&quot;
console.log(num.toString(8)); // &quot;12&quot;
console.log(num.toString(16)); // &quot;a&quot;
</code></pre>
<p>如果你不确定一个值是否时 null 或者 undefined，可以使用<span style="color:yellow">String()</span>转型函数。</p>
<ul>
<li>如果值有toString()方法，则调用该方法（不传参数）并返回结果。</li>
<li>如果值是null，返回”null”</li>
<li>如果值是undefined，返回”undefined”</li>
</ul>
<pre><code>let val1 = 10;
let val2 = null;
let val3;
console.log(String(val1)); //&quot;10&quot;
console.log(String(val2)); //&quot;null&quot;
console.log(String(val3)); //&quot;undefined&quot;
</code></pre>
<h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p>ECMAScript6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p>
<pre><code>let pageHTML = `
&lt;div&gt;
    &lt;a href=&quot;#&quot;&gt;
        &lt;span&gt;joker&lt;/span&gt;
    &lt;/a&gt;
&lt;/div&gt;`;
</code></pre>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p>模板字面量最常用的特性是支持字符串插值，可以在一个连续定义中插入一个或多个值。</p>
<p>模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，之不过求值后得到的是字符串。</p>
<p>模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p>
<pre><code>let name = &quot;tom&quot;;
let age = 23;
let str = `$&#123;name&#125; is $&#123;age&#125; years old`;
</code></pre>
<p>所有插入的值都会使用toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用插值。嵌套的模板字符传无须转义：</p>
<pre><code>console.log(`Hello,$&#123;`World`&#125;!`); //Hello,World
</code></pre>
<p>将表达式转换为字符串时会调用 toString() ：</p>
<pre><code>let foo = &#123;toString: () =&gt; &#39;World&#39;&#125;;
console.log(`Hello,$&#123;foo&#125;!`);
</code></pre>
<p>在插值表达式中调用函数和方法：</p>
<pre><code>function capitalize(word)&#123;
    return `$&#123;word[0].toUpperCase()&#125;$&#123;word.slice(1)&#125;`;
&#125;
console.log(`$&#123;capitalize(&#39;hello&#39;)&#125;,$&#123;capitalize(&#39;world&#39;)&#125;!`); //Hello,World!
</code></pre>
<h3 id="模板字面量标签函数"><a href="#模板字面量标签函数" class="headerlink" title="模板字面量标签函数"></a>模板字面量标签函数</h3><p>模板字面量也支持定义标签函数，而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p>
<p>标签函数的语法是函数名后面直接带一个模板字符串，并从模板字符串中的插值表达式中获取参数</p>
<pre><code>let a = 6;
let b = 9;
function simple(str,aVal,bVal,sum) &#123;
   console.log(str);
   console.log(aVal);
   console.log(bVal);
   console.log(sum);
   return &quot;yes&quot;;
&#125;
let tag = simple`$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;
// [&quot;&quot;,&quot;+&quot;,&quot;=&quot;,&quot;&quot;]
// 6
// 9
// 15
console.log(tag); //yes
</code></pre>
<p>因为表达式参数的数量可变，所以通常使用剩余操作符将他们收集到一个数组中。</p>
<pre><code>let a = 6;
let b = 9;
function simple(str,...expressions) &#123;
   console.log(str);
   for(const expression of expressions)&#123;
       console.log(expression);
   &#125;
   return &quot;yes&quot;;
&#125;
let tag = simple`$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;
// [&quot;&quot;,&quot;+&quot;,&quot;=&quot;,&quot;&quot;]
// 6
// 9
// 15
console.log(tag); //yes
</code></pre>
<h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是转换后的字符表示。为此，可以使用默认的 String.raw 标签函数</p>
<pre><code>console.log(String.raw`\u00A9`);
console.log(String.raw`first\nSecond`);
</code></pre>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">dpp</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2021/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">https://DongPangP.github.io/2021/06/16/数据类型/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://DongPangP.github.io">dpp的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tags"></i><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof"><span class="toc-number">1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Undefined"><span class="toc-number">2.</span> <span class="toc-text">Undefined</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null"><span class="toc-number">3.</span> <span class="toc-text">Null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boolean"><span class="toc-number">4.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number"><span class="toc-number">5.</span> <span class="toc-text">Number</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">5.2.</span> <span class="toc-text">值的范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NaN"><span class="toc-number">5.3.</span> <span class="toc-text">NaN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.4.</span> <span class="toc-text">数值转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">Number()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parseInt"><span class="toc-number">5.4.2.</span> <span class="toc-text">parseInt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parseFloat"><span class="toc-number">5.4.3.</span> <span class="toc-text">parseFloat()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol"><span class="toc-number">6.</span> <span class="toc-text">Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">Symbol的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E7%AC%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%E8%A1%A8"><span class="toc-number">6.2.</span> <span class="toc-text">使用全局符号注册表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%8F%B7%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">使用符号作为属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7"><span class="toc-number">6.4.</span> <span class="toc-text">常用内置符号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.</span> <span class="toc-text">Object类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">字符串的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.2.</span> <span class="toc-text">转换为字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">8.3.</span> <span class="toc-text">模板字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC"><span class="toc-number">8.4.</span> <span class="toc-text">字符串插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A0%87%E7%AD%BE%E5%87%BD%E6%95%B0"><span class="toc-number">8.5.</span> <span class="toc-text">模板字面量标签函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.6.</span> <span class="toc-text">原始字符串</span></a></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="next" href="/2021/06/09/%E5%8F%98%E9%87%8F/">变量 &gt;</a></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">穆飘</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>