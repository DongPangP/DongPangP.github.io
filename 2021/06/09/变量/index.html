<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="theme-color" content="#2d4356"><meta name="baidu-site-verification"><title>变量 | 穆飘</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="穆飘" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/plugins/highlight/atom-one-dark.min.css"><script type="text/javascript" src="/plugins/highlight/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();
</script><script type="text/javascript" src="/js/ready.js" async></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><body class="night"><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">穆飘</a></h1></div><p class="m-desc">别想太多，学就完事了！！</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">归档</a></li><li><span class="dot">●</span><a href="/categories/">分类</a></li><li><span class="dot">●</span><a href="/tags/">标签</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="搜索" onfocus="if(this.value=='搜索'){this.value='';}" onblur="if(this.value==''){this.value='搜索';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">变量</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2021/06/09/%E5%8F%98%E9%87%8F/">2021-06-09</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/">JavaScript高级程序设计笔记</a>&nbsp;&bull;&nbsp;<a href="/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a></span></div></div><div class="p-content"><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript 变量 可以用于保存任何数据类型。</p>
<p>有三个关键字：var、const、let ，其中 var 在 ECMAScript 所有版本均可使用，而 const 和 let 只能在ECMAScript 6 及更晚版本中使用。</p>
<hr>
<h3 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a>var 关键字</h3><p>定义变量可以使用 var 操作符（var是关键字），后面跟变量名（即标识符）：</p>
<pre><code>var message; 
</code></pre>
<p>定义了一个名为 message 的变量，可以用于保存任何类型的值（不初始化的情况下，会保存一个特殊值 undefined）</p>
<pre><code>var message=&quot;hello&quot;;
</code></pre>
<p>这里保存了一个 hello 字符串，像这样初始化变量不会将它标识为字符串类型，只是简单的赋值。之后可以更改保存的值，也可以更改值的类型。例如</p>
<pre><code>var message = &quot;hello&quot;;
message = 100;             //合法，但不推荐这么做
</code></pre>
<h4 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h4><p>使用 var 操作符定义的变量，会成为它的函数的局部变量。</p>
<p>比如，使用var在一个函数内部定义一个变量，就意味着改变量将在函数退出时销毁。</p>
<pre><code>function test()&#123;
    var mes = &quot;hello&quot;;  //局部变量
&#125;
test();
console.log(mes);  // 报错！！！
</code></pre>
<p>但是在函数中定义变量时，<span style="color:yellow">省略var操作符，可以创建一个全局变量</span>。</p>
<pre><code>function test()&#123;
     mes = &quot;hello&quot;;  // 全局变量
&#125;
test();
console.log(mes);  // hello
</code></pre>
<p>只需要调用一次就会创建这个变量，可以在函数外部访问到。</p>
<p><span style="color:red">注意：</span> 虽然可以这么操作但是不建议这么定义全局变量，这样代码很难维护。且在严格模式下这么给未声明的变量赋值，则会导致抛出ReferenceError</p>
<p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：</p>
<pre><code>var message = &quot;hello&quot;,
      found = &quot;false&quot;,
      age = 18;
</code></pre>
<p>因为 ECMAScript 是松散类型，所以使用不同数据类型初始化的变量可以用一条语句来声明。插入换行和空格缩进不是必需的，但这样有利于阅读。</p>
<p><span style="color:red">注意：</span>在严格模式下，不能定义名为eval和arguments的变量，否则会导致语法错误</p>
<h4 id="var声明提升"><a href="#var声明提升" class="headerlink" title="var声明提升"></a>var声明提升</h4><p>使用var时，下面代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域的顶部：</p>
<pre><code>function foo()&#123;
    console.log(age);
    var age = 26;
&#125;
foo(); // undefined
</code></pre>
<p>之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：</p>
<pre><code>function foo()&#123;
    var age;
    console.log(age);
    age = 26;
&#125;
foo(); //undefined
</code></pre>
<p>这就是所谓的 “提升”，也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用var声明同一变量也没有关系：</p>
<pre><code>function foo()&#123;
    var age = 16;
    var age = 26;
    var age = 36;
    console.log(age);
&#125;
foo(); // 36
</code></pre>
<hr>
<h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><p>let声明的范围是有块作用域的，var声明的范围只有全局作用域和函数作用域。</p>
<pre><code>if(true)&#123;
    var name = &quot;tom&quot;;
    console.log(name); // tom
&#125;
console.log(name); // tom

if(true)&#123;
    let name = &quot;tom&quot;;
    console.log(name); // tom
&#125;
console.log(name); // ReferenceError: age 没有定义
</code></pre>
<p>块作用域是函数作用域的子集，因此适用于var的作用域限制同样也适用于let。</p>
<p>let不允许同一个块作用域中出现冗余声明。</p>
<pre><code>var name;
var name;

let age;
let age; // SyntaxError; 标识符age已经声明过了
</code></pre>
<p>JavaScript引擎会记录用于变量声明的标识符及其所在的作用域，因此嵌套使用相同的标识符不会报错。</p>
<pre><code>var name = &quot;tom&quot;;
console.log(name); // tom
if(true)&#123;
    var name = &quot;jerry&quot;;
    console.log(name); // jerry
&#125;

let num = 16;
console.log(num); //16
if(true) &#123;
    let num = 26;
    console.log(num); //26
&#125;
</code></pre>
<p>两个关键字声明的并不是不同类型的变量，而是指出变量在相关作用域如何存在。</p>
<pre><code>var name;
let name; //SyntaxError

let age;
var age; //SyntaxError
</code></pre>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>let声明的变量不会在作用域中提升</p>
<pre><code>console.log(age); // ReferenceError: age 没有定义
let age = 16;
</code></pre>
<p>在解析代码前，JavaScript 引擎也会注意到出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。</p>
<p>在let 声明之前执行瞬间被称为 “暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出 ReferenceError</p>
<h4 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h4><p>使用 var 声明的全局变量会成为 window 对象属性，使用 let 声明的则不会。</p>
<pre><code>var name = &quot;tom&quot;;
console.log(window.name); // tom

let age = 26;
console.log(window.age); // undefined
</code></pre>
<p>但是 let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。</p>
<p>因此，为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p>
<h4 id="条件声明"><a href="#条件声明" class="headerlink" title="条件声明"></a>条件声明</h4><p>使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。=&gt; 所以可以用var声明多个同名变量</p>
<p>因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它</p>
<pre><code>&lt;script&gt;
    var name = &quot;tom&quot;;
    let age = 26;
&lt;/script&gt;

&lt;script&gt;
    // 假设脚本不确定页面中是否已经声明了同名变量
    // 那它可以假设还没有声明过
    
    var name = &quot;jerry&quot;;
    // 这里没有问题，因为可以被作为一个提升声明来处理
    // 不需要检查之前是否声明过同名变量
    
    let age = 36；
    // 如果age之前声明过，这里会报错
&lt;/script&gt;
</code></pre>
<p>使用 try/catch 语句 或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。</p>
<p>let 不能依赖于条件声明模式。</p>
<h4 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h4><p>使用 var ，for循环定义的迭代变量会渗透到循环体外部。</p>
<pre><code>for(var i=0 ; i&lt;5 ; ++i)&#123;
    //循环逻辑
&#125;
console.log(i); // 5
</code></pre>
<p>使用 let ，这个问题就消失了，因为迭代变量的作用域仅限于for循环内部：</p>
<pre><code>for(let i=0 ; i&lt;5 ; ++i)&#123;
    //循环逻辑
&#125;
console.log(i); // ReferenceError: i没有定义
</code></pre>
<pre><code>for(var i=0 ; i&lt;5; ++i)&#123;
    setTimeout(()=&gt;console.log(i),0);
&#125;
//实际输出 5、5、5、5、5
</code></pre>
<p>var 在 for 循环中定义的变量 i 没有块级作用域，全局只有一个 i，setTimeout方法执行时 for循环就已经执行完了。所以得到的结果均为 5</p>
<p>而使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以可以输出我们所期望的值。这个每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环。</p>
<hr>
<h3 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h3><p>const 的行为和 let 基本相同，唯一重要的点是用 const 声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p>
<pre><code>const age = 26;
age = 16;         //TypeError: 给常量赋值

// const 也不允许重复声明
const name = &quot;tom&quot;;
const name = &quot;jerry&quot;;  // SyntaxError

// const 声明的作用域也是块
const name = &quot;tom&quot;;
if(true) &#123;
    const name = &quot;jerry&quot;;
&#125;
console.log(name); // tom
</code></pre>
<p>const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。</p>
<pre><code>const person = &#123;&#125;;
person.name = &quot;tom&quot;;
</code></pre>
<p>javaScript 引擎会为 for 循环中的let声明分别创建独立的变量实例，虽然 const变量会跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）。</p>
<pre><code>for(const i = 0;i&lt;5;++i)&#123;&#125; // TypeError: 给常量赋值
</code></pre>
<p>不过，如果你只想用 const 声明一个不会被修改的for循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。</p>
<pre><code>let i = 0;
for (const j=7;i&lt;5;++i)&#123;
    console.log(j);
&#125;
// 7,7,7,7,7

for (const key in &#123;a: 1,b: 2&#125;)&#123;
    console.log(key);
&#125;
// a,b

for (const value of [1,2,3,4,5])&#123;
    console.log(value);
&#125;
// 1,2,3,4,5
</code></pre>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">dpp</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2021/06/09/%E5%8F%98%E9%87%8F/">https://DongPangP.github.io/2021/06/09/变量/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="https://DongPangP.github.io">dpp的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tags"></i><a href="/tags/JavaScript/">JavaScript</a><a href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a></span></div><aside id="toc"><div class="toc-title">目录</div><nav><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.</span> <span class="toc-text">var 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#var%E5%A3%B0%E6%98%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">var声明作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#var%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">var声明提升</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.</span> <span class="toc-text">let声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">暂时性死区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.2.</span> <span class="toc-text">全局声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.3.</span> <span class="toc-text">条件声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84let%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.4.</span> <span class="toc-text">for循环中的let声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E5%A3%B0%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">const声明</span></a></li></ol></li></ol></nav></aside></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="prev" href="/2021/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">&lt; 数据类型</a><a class="next" href="/2021/06/05/dom%E5%9F%BA%E7%A1%80_Document%E7%B1%BB%E5%9E%8B/">dom基础_Document类型 &gt;</a></div></section><footer><p>Copyright © 2016 - 2021 <a href="/." rel="nofollow">穆飘</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br>Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script></body></html>