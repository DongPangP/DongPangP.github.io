<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>穆飘</title>
  
  
  <link href="https://dongpangp.github.io/atom.xml" rel="self"/>
  
  <link href="https://dongpangp.github.io/"/>
  <updated>2021-06-17T02:41:30.940Z</updated>
  <id>https://dongpangp.github.io/</id>
  
  <author>
    <name>dpp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据类型</title>
    <link href="https://dongpangp.github.io/2021/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://dongpangp.github.io/2021/06/16/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-06-16T00:30:35.000Z</published>
    <updated>2021-06-17T02:41:30.940Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 有6种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。（Symbol 符号 是ECMAScript6新增的）</p><p>1种复杂数据类型 Object（对象）：Object 是一种无序名值对的集合</p><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。</p><p>对一个值使用 typeof 操作符会返回下列字符串之一：</p><ul><li>undefined  表示值未定义；</li><li>boolean     表示值为布尔值；</li><li>string         表示值为字符串；</li><li>number      表示值为数值；</li><li>object         表示值为对象（而不是函数）或 null；</li><li>function      表示值为函数；</li><li>symbol       表示值为符号；</li></ul><p>缺点：</p><ol><li>不能判断变量具体的数据类型，比如数组、正则、日期对象，因为都会返回Object ，不过可以判断 function。</li><li>判断 null 的时候会返回 Object ；判断 NaN 的时候返回 number </li></ol><p>注意：</p><p>严格来说，函数在ECMAScript 中被认定为<span style="color:pink">对象</span>,并不代表一种数据类型，可以使用 typeof 来区分函数和其他对象</p><h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>Undefined 只有一个值，就是特殊值 undefined 。</p><p>当使用 let 或 var 声明变量但没有初始化时，就相当于给变量赋予了 undefined 值</p><pre><code>let mes;console.log(mes == undefined); // truelet name; //这个变量被声明了，只是值为undefined//确保没有声明过这个变量//let age;console.log(name); //undefinedconsole.log(age);  //报错</code></pre><p>无论是否声明的变量，使用typeof均返回 undefined</p><pre><code>let name; //这个变量被声明了，只是值为undefined//确保没有声明过这个变量//let age;console.log(typeof name); //undefinedconsole.log(typeof age);  //undefined</code></pre><p>因为声明变量或未声明变量，使用typeof检测都会得到undefined。所以在声明变量的时候应该直接初始化，这样可以使用typeof检测哪些给定变量未进行声明。</p><p>undefined 是一个假值。</p><pre><code>let message;  // 这个变量被声明了，只是值为undefinedif(message)&#123;    // 不会执行&#125;if(!message)&#123;    // 会执行&#125;if(age)&#123;    // age没有声明直接报错&#125;</code></pre><h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>Null 类型同样只有一个值，即特殊值 null。 null值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 object 的原因。</p><pre><code>let car = null;console.log(typeof car); //object</code></pre><p>在定义将要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否之后赋予了一个对象的引用。</p><pre><code>if(car != null)&#123;    // car是一个对象的引用&#125;</code></pre><p>undefined 值由 null 派生而来，因此 ECMA-262 将它们定义为表面相等，例如：</p><pre><code>console.log(null == undefined); // true</code></pre><p>用操作符（==）比较 null 和 undefined 始终返回 true，但是这个操作符会为了比较而转换它的操作数。</p><p>undefined 不能显示的用于变量值的设置，但是 null 需要显示的进行使用。任何时候，只要变量保存对象，而当时又没有对象可以保存，则需要使用 null 进行填充。</p><p>null 是一个假值</p><pre><code>let message = null;let age;if(message)&#123;    // 不会执行&#125;if(!message)&#123;    // 执行&#125;if(age)&#123;    // 判断 undefined 不会执行&#125;if(!age)&#123;    // 判断 undefined 会执行&#125;</code></pre><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>Boolean(布尔值)类型是ECMAScript中使用最频繁的类型之一，有两个字面值：true 和 false</p><p>注意：<span style="color:yellow">true和false区分大小写</span></p><p>虽然布尔值只有两个，但所有其他ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的<span   style="color:yellow">Boolean()</span>转型函数：</p><pre><code>let message = &quot;Hello World&quot;;let bool = Boolean(message);</code></pre><p>Boolean() 转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。转换规则：</p><table><thead><tr><th>数据类型</th><th>转换为true</th><th>转换为false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>非空字符串</td><td>“”(空字符串)</td></tr><tr><td>Number</td><td>非零数值（包括无穷值）</td><td>0、NaN</td></tr><tr><td>Object</td><td>任意对象</td><td>null</td></tr><tr><td>Undefined</td><td>不存在</td><td>undefined</td></tr></tbody></table><p>像 if 等流控制语句会自动执行其他类型值到布尔值的转换。</p><pre><code>let message = &quot;hello world&quot;;if(message)&#123;    console.log(&quot;true&quot;);&#125;</code></pre><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Number 表示整数和浮点数。不同的数值类型相应的也有不同的数值字面量格式。</p><p>最基本数值字面量是十进制整数：</p><pre><code>let num1 = 233;</code></pre><p>整数也可以使用八进制和十六进制。八进制字面量第一个值必须是零（0），然后是相应的八进制数（0-7），如果字面量中包含了数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当做十进制数。</p><pre><code>let octalNum1 = 070;  // 56let octalNum2 = 079;  //当作79处理let octalNum3 = 08;   //当作8处理</code></pre><p>八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。（严格模式下，前缀0被视为语法错误，需要使用前缀0o）</p><p>十六进制字面量，前缀0x，然后是十六进制数。十六进制数大小写均可：</p><pre><code>let hexNum1 = 0xA;  // 10let hexNum2 = 0x1f; // 31</code></pre><p>注意：</p><p>由于JavaScript保存数值的方式，实际上可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>要定义浮点数，数值中必须包含小数点，而且小数点后必须至少有一个数字。虽然小数点前不是必须有整数，但是推荐加上。</p><pre><code>let floatNum1 = 2.33;let floatNum2 = 0.2;let floatNum3 = .6;  //有效但不推荐</code></pre><p>因为存储浮点数使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法的将值转换为整数。在小数点后没有数字的情况，数值会转换为整数。</p><pre><code>let floatNum1 = 1.; //小数点后没有数字，当成整数1处理let floatNum2 = 10.0; //小数点后面是零，当成整数10处理</code></pre><p>对于非常大或者非常小的值，可以使用科学计数法</p><pre><code>let floatNum1 = 3.125e7; //31250000let floatNum2 = 3e-17;  //0.000 000 000 000 000 03</code></pre><p>浮点数的精确度最高可达17位小数，但是算术计算中远不如整数精确。例如：0.1加0.2得到的不是0.3，而是0.300 000 000 000 000 04</p><pre><code>// 所以不要判断浮点数if(a + b == 0.3) &#123;    console.log(&quot;you got 0.3&quot;);&#125;</code></pre><p>这里检测的两个数值之和是否等于0.3。如果两个数值分别是0.05和0.25，或者0.15和0.15，那没问题。但如果是0.1和0.2，则判断不成功。之所以存在这种舍入错误，是因为使用了IEEE 754 数值。</p><h3 id="值的范围"><a href="#值的范围" class="headerlink" title="值的范围"></a>值的范围</h3><p>最小值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e-324</p><p>最大值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308</p><p>Infinity 正无穷大；-Infinity 负无穷大</p><p>要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用 isFinite() 函数</p><pre><code>let result = Number.MAX_VALUE + Number.MAX_VALUE;console.log(isFinite(result));  //false</code></pre><p>Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 分别表示 -Infinity 和 Infinity</p><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>有一个特殊值叫 NaN，意思是 “不是数值” （Not a Number）,用于表示本来要返回数值的操作失败了（而不是抛出错误）。</p><p>比如，用 0 除任意数值在其他语言中通常会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0、-0相除会返回NaN：</p><pre><code>console.log(0/0); // NaNconsole.log(-0/+0); // NaN</code></pre><p>如果分子是非 0 值，分母是有符号0 或无符号 0，则会返回 Infinity 或 -Infinity:</p><pre><code>console.log(5/0) ; //Infinityconsole.log(5/-0); //-Infinity</code></pre><ul><li>任何涉及NaN的操作始终会返回NaN（如NaN/10）</li><li>NaN不等于包括NaN在内的任何值</li></ul><p>ECMAScript 提供了<span style= "color:yellow"> isNaN()</span>。该函数接收任意数据类型，然后判断这个参数是否（不是数值）。把一个数值传给 isNaN() 后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换为数值，如字符串”10”或布尔值。任何不能转换为数值的值都会导致整个函数返回 true</p><pre><code>console.log(isNaN(NaN)); //trueconsole.log(isNaN(10));  //falseconsole.log(isNaN(&quot;10&quot;)); //falseconsole.log(isNaN(&quot;blue&quot;)); //trueconsole.log(isNaN(true)); //false</code></pre><p>注意：虽然不常见，但 isNaN() 可以用于测试对象。此时，首先会调用对象的 valueOf() 方法，然后再确认返回的值是否可以转换为数值。如果不能，再调用 toString() 方法，并测试其返回值。这通常时 ECMAScript 内置函数和操作符的工作方式。</p><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p>有 3 个函数可以将非数值转换为数值：<span style="color:yellow">Number() </span>、<span style="color:yellow">parseInt()</span> 和<span style="color:yellow"> parseFloat()</span></p><p>Number() 是转型函数，可用于任何数据类型。后面两个主要用于字符串转换为数值。</p><h4 id="Number-1"><a href="#Number-1" class="headerlink" title="Number()"></a>Number()</h4><p>Number() 基于以下规则进行转换：</p><ul><li><p>布尔值，true 转换为 1 ，false 转换为 0</p></li><li><p>数值，直接返回</p></li><li><p>null，返回0</p></li><li><p>undefined，返回 NaN</p></li><li><p>字符串，应用以下规则</p><p>1、如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”) 返回1，Number(“123”) 返回123，     Number(“011”) 返回11（忽略前面的零）</p><p>2、如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）</p><p>3、如果字符串包含有效的十六进制格式如 “0xf”，则会转换为与该十六进制对应的十进制整数值。</p><p>4、如果是空字符串（不包含字符），则返回0</p><p>5、如果字符串包含除上述情况之外的其他字符，则返回 NaN</p></li><li><p>对象，调用 valueOf() 方法，并按照上述规则转换返回的值。如果转换结果是NaN，则调用 toString() 方法，并按照转换字符串的规则转换。</p></li></ul><pre><code>let num1 = Number(&quot;hello123&quot;); //NaNlet num2 = Number(&quot;&quot;);         //0let num3 = number(&quot;0xff&quot;);     //255</code></pre><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>考虑到使用 Number() 函数转换字符串时相对复杂且优点反常规，通常在需要得到整数时可以优先使用 parseInt() 函数。</p><p>parseInt() 函数更专注于字符串是否包含数值模式。</p><ul><li>字符串最前面的空格会被忽略，从第一个非空字符开始转换。如果第一个字符不是数值字符、加号或减号，立即返回 NaN。</li></ul><pre><code>let num1 = parseInt(&quot;&quot;);         // NaNlet num2 = parseInt(&quot; 234&quot;);       //234let num3 = parseInt(&quot;hello234&quot;); // NaN</code></pre><ul><li>如果第一个字符时数值字符、加号或减号，则继续依次检测每个字符，知道字符串末尾，或碰到非数值字符串</li></ul><pre><code>let num4 = parseInt(&quot;1234hello&quot;); // 1234let num5 = parseInt(&quot;22.5&quot;);      // 22let num6 = parseInt(&quot;0xA&quot;);       // 10</code></pre><ul><li>不同的数值格式容易混淆，因此 parseInt() 也接收第二个参数，用于指定进制数</li></ul><pre><code>let num7 = parseInt(&quot;AF&quot;,16);  // 175let num8 = parseInt(&quot;AF&quot;);         // NaNlet num9 = parseInt(&quot;10&quot;, 2);   // 2,按二进制进行解析let num10 = parseInt(&quot;10&quot;, 8);  // 8,按八进制进行解析let num11 = parseInt(&quot;10&quot;, 10);  // 10,按十进制进行解析let num12 = parseInt(&quot;10&quot;, 16);  // 16,按十六进制进行解析</code></pre><h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><p>parseFloat() 函数的工作方式和 parseInt() 类似。</p><p>区别：</p><ul><li>它也是解析到字符串末尾或者解析到一个无效的浮点数值字符位置。这意味着第一次出现的小数点是有效的，但第二次出现就无效了，此时字符串剩余的字符会被忽略。因此 “2.33.33” 将转换为 2.33</li><li>它始终忽略字符串开头的零。整个函数能识别前面讨论的说有浮点格式，以及十进制格式（开头的零始终忽略）。</li><li>十六进制数值始终会返回 0 ，因为parseFloat()只解析十进制，因此不能指定底数。</li><li>如果字符串表示为整数，则返回整数</li></ul><pre><code>let num1 = parseFloat(&quot;1234blue&quot;); //1234let num2 = parseFloat(&quot;0xA&quot;);      //0let num3 = parseFloat(&quot;0908.5&quot;);   //908.5let num4 = parseFloat(&quot;3.125e7&quot;);  //31250000</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p><strong>Symbol(符号)</strong>是 ECMAScript6 新增的数据类型。符号是原始值，且符号实例唯一、不可变。<span style="color:yellow">用于确保对象属性使用唯一标识符，不会发生属性冲突的危险。</span></p><h3 id="Symbol的基本用法"><a href="#Symbol的基本用法" class="headerlink" title="Symbol的基本用法"></a>Symbol的基本用法</h3><p>Symbol 需要使用 Symbol() 函数初始化。 因为 Symbol 本身是原始类型，所以 typeof 操作符对 Symbol 返回 Symbol</p><pre><code>let sym = Symbol();console.log(typeof sym); //Symbol</code></pre><p>调用 Symbol() 函数时，也可以传入一个字符串参数作为对符号的描述 (description) ，将来可以通过整个字符串来调试代码。但是，这个字符串参数与符号定义和标识完全无关。</p><pre><code>let one = Symbol(&#39;ann&#39;);let two = Symbol(&#39;ann&#39;);console.log(one == two);  // false</code></pre><p>Symbol没有字面量语法，所以按照规范只要创建Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性。</p><pre><code>let name = &quot;tom&quot; ; //字面量语法// Symbol没有这种语法，只能通过Symbol()let age = Symbol();</code></pre><p>Symbol() 函数不能与new关键字一起作为构造函数使用</p><pre><code>let myBool = new Boolean();console.log(typeof myBool); // objectlet myString = new String();console.log(typeof myString); // objectlet myNumber = new Number();console.log(typeof myNumber); //objectlet mySymbol = new Symbol(); // TypeError: Symbol is not a constructor//如果你确实想使用符号包装对象，可以借用Object()函数let mySymbol2 = Symbol();let myWrappedSymbol = Object(mySymbol2);console.log(typeof myWrappedSymbol); //object</code></pre><h3 id="使用全局符号注册表"><a href="#使用全局符号注册表" class="headerlink" title="使用全局符号注册表"></a>使用全局符号注册表</h3><p>如果运行时的不同部分需要共享和重用Symbol实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用Symbol。</p><p><span style="color:yellow">Symbol.for()</span>对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p><pre><code>let fooGlobalSymbol = Symbol.for(&quot;foo&quot;);let other = Symbol.for(&quot;foo&quot;);console.log(fooGlobalSymbol === other); //true</code></pre><p>即使采用相同的描述，在全局注册表中定义的符号跟使用Symbol()定义的符号也并不相同。</p><pre><code>let localSymbol = Symbol(&quot;tom&quot;);let globalSymbol = Symbol.for(&quot;tom&quot;);console.log(localSymbol === globalSymbol);</code></pre><p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给 Symbol.for()的任何值都会被转换为字符串。注册表中使用的键也会被用作Symbol描述。</p><pre><code>let emptySymbol = Symbol.for();console.log(emptySymbol); // Symbol(undefined)</code></pre><p>可以使用<span style="color:yellow">Symbol.keyFor()</span>来查询全局注册表，接收Symbol，返回该全局符号对应的字符串键</p><pre><code>//创建全局符号let s = Symbol.for(&quot;tom&quot;);console.log(Symbol.keyFor(s)); &quot;tom&quot;//创建普通符号let s2 = Symbol(&quot;tom&quot;);console.log(Symbol.keyFor(s2)); //undefined//如果传给keyFor的不是符号Symbol.keyFor(&quot;123&quot;);  //TypeError: 123 is not Symbol</code></pre><h3 id="使用符号作为属性"><a href="#使用符号作为属性" class="headerlink" title="使用符号作为属性"></a>使用符号作为属性</h3><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties() 定义的属性。</p><p>对象字面量属性只能在计算属性语法中使用符号作为属性：</p><pre><code>let s1 = Symbol(&quot;a&quot;),      s2 = Symbol(&quot;b&quot;),    s3 = Symbol(&quot;c&quot;),    s4 = Symbol(&quot;d&quot;),let o = &#123;    [s1]: &quot;a val&quot;&#125;Object.defineProperty(o,s2,&#123;value: &#39;b val&#39;&#125;);Object.defineProperties(o,&#123;    [s3]: &#123;value: &quot;c val&quot;&#125;,    [s4]: &#123;value: &quot;d val&quot;&#125;&#125;)</code></pre><ul><li>Object.getOwnPropertyNames() 返回对象实例的常规属性数组</li><li>Object.getOwnPropertySymbols() 返回对象实例的符号属性数组</li><li>Object.getOwnPropertyDescriptors() 返回同时包含常规和符号属性描述符的对象</li><li>Reflect.ownKeys() 返回两种类型的键</li></ul><pre><code>let s1 = Symbol(&#39;foo&#39;),      s2 = Symbol(&#39;bar&#39;);let o = &#123;    [s1]: &#39;foo val&#39;,    [s2]: &#39;bar val&#39;,    baz: &#39;baz val&#39;,    qux: &#39;qux val&#39;&#125;console.log(Object.getOwnPropertySymbols(o));//[Symbol(foo),Symbol(bar)]console.log(Object.getOwnPropertyNames(o));//[&quot;baz&quot;,&quot;qux&quot;]console.log(Object.getOwnPropertyDescriptors(o));//&#123;baz: &#123;...&#125;,qux:&#123;...&#125;,Symbol(foo):&#123;...&#125;,Symbol(bar):&#123;...&#125;&#125;console.log(Reflect.ownKeys(o));//[&quot;baz&quot;,&quot;qux&quot;,Symbol(foo),Symbol(bar)]</code></pre><p>因为符号属性是对内存符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显示的保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键。</p><pre><code>let o = &#123;    [Symbol(&#39;foo&#39;)]: &#39;foo val&#39;,    [Symbol(&#39;bar&#39;)]: &#39;bar val&#39;&#125;let barSymbol = Object.getOwnPropertySymbols(o).find(symbol =&gt; symbol.toString().match(/bar/));console.log(barSymbol); // Symbol(bar)</code></pre><h3 id="常用内置符号"><a href="#常用内置符号" class="headerlink" title="常用内置符号"></a>常用内置符号</h3><p>ECMAScript 也引入了一批常用内置符号，用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。</p><p>在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为 @@。 比如@@Iterator 指的就是 Symbol.iterator</p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过new操作符后跟对象类型的名称来创建。</p><pre><code>// 先通过创建Object类型的实例来创建自己的对象，然后再给对象添加属性和方法let obj = new Object();// 如果没有参数可以省略括号（不推荐）let obj2 = new Object;</code></pre><p>类似Java中的 java.lang.Object，ECMAScript 中的 Object 也是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个Object实例都有以下属性和方法：</p><ul><li>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object() 函数</li><li>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如o.hasOwnProperty(“name”)）或符号。</li><li>isPrototypeOf(object)：用于判断当前对象是否是另一个对象的原型</li><li>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用 for-in 语句枚举。与hasOwnProperty()一样，属性名必须是字符串。</li><li>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li><li>toString()：返回对象的字符串表示</li><li>valueOf()：返回对象相应的字符串、数值或布尔值表示。通常与 toString() 的返回值相同</li></ul><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。</p><p>字符串可以使用双引号(“)、单引号(‘)、反引号(`)。</p><h3 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h3><p>ECMAScript中的字符串是不可变的，即一旦创建，要修改某个变量中的字符串的值，必须先销毁原始字符串，然后将包含新值的另一个字符串保存到该变量中。如下所示：</p><pre><code>let lang = &quot;Java&quot;;lang = lang + &quot;Script&quot;;</code></pre><p>整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上 “Java” 和 “Script”，最后销毁原始的字符串 “Java” 和 “Script”</p><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p><span style="color:yellow">toString()</span>返回当前值的字符串等价物。可用于数值、布尔值、对象和字符串值（字符串值也有toString()方法，该方法只是简单的返回自身的一个副本），null和undefined 值没有 toString() 方法。</p><p>toString()可以接收参数，将数值转换为二进制、八进制、十六进制数的字符串</p><pre><code>let num = 10;console.log(num.toString()); // &quot;10&quot;console.log(num.toString(2)); // &quot;1010&quot;console.log(num.toString(8)); // &quot;12&quot;console.log(num.toString(16)); // &quot;a&quot;</code></pre><p>如果你不确定一个值是否时 null 或者 undefined，可以使用<span style="color:yellow">String()</span>转型函数。</p><ul><li>如果值有toString()方法，则调用该方法（不传参数）并返回结果。</li><li>如果值是null，返回”null”</li><li>如果值是undefined，返回”undefined”</li></ul><pre><code>let val1 = 10;let val2 = null;let val3;console.log(String(val1)); //&quot;10&quot;console.log(String(val2)); //&quot;null&quot;console.log(String(val3)); //&quot;undefined&quot;</code></pre><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p>ECMAScript6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p><pre><code>let pageHTML = `&lt;div&gt;    &lt;a href=&quot;#&quot;&gt;        &lt;span&gt;joker&lt;/span&gt;    &lt;/a&gt;&lt;/div&gt;`;</code></pre><h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p>模板字面量最常用的特性是支持字符串插值，可以在一个连续定义中插入一个或多个值。</p><p>模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，之不过求值后得到的是字符串。</p><p>模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><pre><code>let name = &quot;tom&quot;;let age = 23;let str = `$&#123;name&#125; is $&#123;age&#125; years old`;</code></pre><p>所有插入的值都会使用toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用插值。嵌套的模板字符传无须转义：</p><pre><code>console.log(`Hello,$&#123;`World`&#125;!`); //Hello,World</code></pre><p>将表达式转换为字符串时会调用 toString() ：</p><pre><code>let foo = &#123;toString: () =&gt; &#39;World&#39;&#125;;console.log(`Hello,$&#123;foo&#125;!`);</code></pre><p>在插值表达式中调用函数和方法：</p><pre><code>function capitalize(word)&#123;    return `$&#123;word[0].toUpperCase()&#125;$&#123;word.slice(1)&#125;`;&#125;console.log(`$&#123;capitalize(&#39;hello&#39;)&#125;,$&#123;capitalize(&#39;world&#39;)&#125;!`); //Hello,World!</code></pre><h3 id="模板字面量标签函数"><a href="#模板字面量标签函数" class="headerlink" title="模板字面量标签函数"></a>模板字面量标签函数</h3><p>模板字面量也支持定义标签函数，而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p><p>标签函数的语法是函数名后面直接带一个模板字符串，并从模板字符串中的插值表达式中获取参数</p><pre><code>let a = 6;let b = 9;function simple(str,aVal,bVal,sum) &#123;   console.log(str);   console.log(aVal);   console.log(bVal);   console.log(sum);   return &quot;yes&quot;;&#125;let tag = simple`$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;// [&quot;&quot;,&quot;+&quot;,&quot;=&quot;,&quot;&quot;]// 6// 9// 15console.log(tag); //yes</code></pre><p>因为表达式参数的数量可变，所以通常使用剩余操作符将他们收集到一个数组中。</p><pre><code>let a = 6;let b = 9;function simple(str,...expressions) &#123;   console.log(str);   for(const expression of expressions)&#123;       console.log(expression);   &#125;   return &quot;yes&quot;;&#125;let tag = simple`$&#123;a&#125;+$&#123;b&#125;=$&#123;a+b&#125;`;// [&quot;&quot;,&quot;+&quot;,&quot;=&quot;,&quot;&quot;]// 6// 9// 15console.log(tag); //yes</code></pre><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是转换后的字符表示。为此，可以使用默认的 String.raw 标签函数</p><pre><code>console.log(String.raw`\u00A9`);console.log(String.raw`first\nSecond`);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ECMAScript 有6种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。（Symbol 符号 是ECMAScript6新增的）&lt;/p&gt;
&lt;p&gt;1种复杂数据类型 Object（对象）：Object</summary>
      
    
    
    
    <category term="JavaScript高级程序设计笔记" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    
    <category term="语言基础" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="https://dongpangp.github.io/tags/JavaScript/"/>
    
    <category term="语言基础" scheme="https://dongpangp.github.io/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>变量</title>
    <link href="https://dongpangp.github.io/2021/06/09/%E5%8F%98%E9%87%8F/"/>
    <id>https://dongpangp.github.io/2021/06/09/%E5%8F%98%E9%87%8F/</id>
    <published>2021-06-09T11:10:35.000Z</published>
    <updated>2021-06-10T06:30:25.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript 变量 可以用于保存任何数据类型。</p><p>有三个关键字：var、const、let ，其中 var 在 ECMAScript 所有版本均可使用，而 const 和 let 只能在ECMAScript 6 及更晚版本中使用。</p><hr><h3 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a>var 关键字</h3><p>定义变量可以使用 var 操作符（var是关键字），后面跟变量名（即标识符）：</p><pre><code>var message; </code></pre><p>定义了一个名为 message 的变量，可以用于保存任何类型的值（不初始化的情况下，会保存一个特殊值 undefined）</p><pre><code>var message=&quot;hello&quot;;</code></pre><p>这里保存了一个 hello 字符串，像这样初始化变量不会将它标识为字符串类型，只是简单的赋值。之后可以更改保存的值，也可以更改值的类型。例如</p><pre><code>var message = &quot;hello&quot;;message = 100;             //合法，但不推荐这么做</code></pre><h4 id="var声明作用域"><a href="#var声明作用域" class="headerlink" title="var声明作用域"></a>var声明作用域</h4><p>使用 var 操作符定义的变量，会成为它的函数的局部变量。</p><p>比如，使用var在一个函数内部定义一个变量，就意味着改变量将在函数退出时销毁。</p><pre><code>function test()&#123;    var mes = &quot;hello&quot;;  //局部变量&#125;test();console.log(mes);  // 报错！！！</code></pre><p>但是在函数中定义变量时，<span style="color:yellow">省略var操作符，可以创建一个全局变量</span>。</p><pre><code>function test()&#123;     mes = &quot;hello&quot;;  // 全局变量&#125;test();console.log(mes);  // hello</code></pre><p>只需要调用一次就会创建这个变量，可以在函数外部访问到。</p><p><span style="color:red">注意：</span> 虽然可以这么操作但是不建议这么定义全局变量，这样代码很难维护。且在严格模式下这么给未声明的变量赋值，则会导致抛出ReferenceError</p><p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：</p><pre><code>var message = &quot;hello&quot;,      found = &quot;false&quot;,      age = 18;</code></pre><p>因为 ECMAScript 是松散类型，所以使用不同数据类型初始化的变量可以用一条语句来声明。插入换行和空格缩进不是必需的，但这样有利于阅读。</p><p><span style="color:red">注意：</span>在严格模式下，不能定义名为eval和arguments的变量，否则会导致语法错误</p><h4 id="var声明提升"><a href="#var声明提升" class="headerlink" title="var声明提升"></a>var声明提升</h4><p>使用var时，下面代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域的顶部：</p><pre><code>function foo()&#123;    console.log(age);    var age = 26;&#125;foo(); // undefined</code></pre><p>之所以不会报错，是因为 ECMAScript 运行时把它看成等价于如下代码：</p><pre><code>function foo()&#123;    var age;    console.log(age);    age = 26;&#125;foo(); //undefined</code></pre><p>这就是所谓的 “提升”，也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次使用var声明同一变量也没有关系：</p><pre><code>function foo()&#123;    var age = 16;    var age = 26;    var age = 36;    console.log(age);&#125;foo(); // 36</code></pre><hr><h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><p>let声明的范围是有块作用域的，var声明的范围只有全局作用域和函数作用域。</p><pre><code>if(true)&#123;    var name = &quot;tom&quot;;    console.log(name); // tom&#125;console.log(name); // tomif(true)&#123;    let name = &quot;tom&quot;;    console.log(name); // tom&#125;console.log(name); // ReferenceError: age 没有定义</code></pre><p>块作用域是函数作用域的子集，因此适用于var的作用域限制同样也适用于let。</p><p>let不允许同一个块作用域中出现冗余声明。</p><pre><code>var name;var name;let age;let age; // SyntaxError; 标识符age已经声明过了</code></pre><p>JavaScript引擎会记录用于变量声明的标识符及其所在的作用域，因此嵌套使用相同的标识符不会报错。</p><pre><code>var name = &quot;tom&quot;;console.log(name); // tomif(true)&#123;    var name = &quot;jerry&quot;;    console.log(name); // jerry&#125;let num = 16;console.log(num); //16if(true) &#123;    let num = 26;    console.log(num); //26&#125;</code></pre><p>两个关键字声明的并不是不同类型的变量，而是指出变量在相关作用域如何存在。</p><pre><code>var name;let name; //SyntaxErrorlet age;var age; //SyntaxError</code></pre><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>let声明的变量不会在作用域中提升</p><pre><code>console.log(age); // ReferenceError: age 没有定义let age = 16;</code></pre><p>在解析代码前，JavaScript 引擎也会注意到出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。</p><p>在let 声明之前执行瞬间被称为 “暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出 ReferenceError</p><h4 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h4><p>使用 var 声明的全局变量会成为 window 对象属性，使用 let 声明的则不会。</p><pre><code>var name = &quot;tom&quot;;console.log(window.name); // tomlet age = 26;console.log(window.age); // undefined</code></pre><p>但是 let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。</p><p>因此，为了避免 SyntaxError，必须确保页面不会重复声明同一个变量。</p><h4 id="条件声明"><a href="#条件声明" class="headerlink" title="条件声明"></a>条件声明</h4><p>使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。=&gt; 所以可以用var声明多个同名变量</p><p>因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它</p><pre><code>&lt;script&gt;    var name = &quot;tom&quot;;    let age = 26;&lt;/script&gt;&lt;script&gt;    // 假设脚本不确定页面中是否已经声明了同名变量    // 那它可以假设还没有声明过        var name = &quot;jerry&quot;;    // 这里没有问题，因为可以被作为一个提升声明来处理    // 不需要检查之前是否声明过同名变量        let age = 36；    // 如果age之前声明过，这里会报错&lt;/script&gt;</code></pre><p>使用 try/catch 语句 或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。</p><p>let 不能依赖于条件声明模式。</p><h4 id="for循环中的let声明"><a href="#for循环中的let声明" class="headerlink" title="for循环中的let声明"></a>for循环中的let声明</h4><p>使用 var ，for循环定义的迭代变量会渗透到循环体外部。</p><pre><code>for(var i=0 ; i&lt;5 ; ++i)&#123;    //循环逻辑&#125;console.log(i); // 5</code></pre><p>使用 let ，这个问题就消失了，因为迭代变量的作用域仅限于for循环内部：</p><pre><code>for(let i=0 ; i&lt;5 ; ++i)&#123;    //循环逻辑&#125;console.log(i); // ReferenceError: i没有定义</code></pre><pre><code>for(var i=0 ; i&lt;5; ++i)&#123;    setTimeout(()=&gt;console.log(i),0);&#125;//实际输出 5、5、5、5、5</code></pre><p>var 在 for 循环中定义的变量 i 没有块级作用域，全局只有一个 i，setTimeout方法执行时 for循环就已经执行完了。所以得到的结果均为 5</p><p>而使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例，所以可以输出我们所期望的值。这个每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环。</p><hr><h3 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h3><p>const 的行为和 let 基本相同，唯一重要的点是用 const 声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p><pre><code>const age = 26;age = 16;         //TypeError: 给常量赋值// const 也不允许重复声明const name = &quot;tom&quot;;const name = &quot;jerry&quot;;  // SyntaxError// const 声明的作用域也是块const name = &quot;tom&quot;;if(true) &#123;    const name = &quot;jerry&quot;;&#125;console.log(name); // tom</code></pre><p>const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。</p><pre><code>const person = &#123;&#125;;person.name = &quot;tom&quot;;</code></pre><p>javaScript 引擎会为 for 循环中的let声明分别创建独立的变量实例，虽然 const变量会跟 let 变量很相似，但是不能用 const 来声明迭代变量（因为迭代变量会自增）。</p><pre><code>for(const i = 0;i&lt;5;++i)&#123;&#125; // TypeError: 给常量赋值</code></pre><p>不过，如果你只想用 const 声明一个不会被修改的for循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。</p><pre><code>let i = 0;for (const j=7;i&lt;5;++i)&#123;    console.log(j);&#125;// 7,7,7,7,7for (const key in &#123;a: 1,b: 2&#125;)&#123;    console.log(key);&#125;// a,bfor (const value of [1,2,3,4,5])&#123;    console.log(value);&#125;// 1,2,3,4,5</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;ECMAScript 变量 可以用于保存任何数据类型。&lt;/p&gt;
&lt;p&gt;有三个关键字：var、const、let ，其中 var 在 ECMA</summary>
      
    
    
    
    <category term="JavaScript高级程序设计笔记" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    
    <category term="语言基础" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JavaScript" scheme="https://dongpangp.github.io/tags/JavaScript/"/>
    
    <category term="语言基础" scheme="https://dongpangp.github.io/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>dom基础_Document类型</title>
    <link href="https://dongpangp.github.io/2021/06/05/dom%E5%9F%BA%E7%A1%80_Document%E7%B1%BB%E5%9E%8B/"/>
    <id>https://dongpangp.github.io/2021/06/05/dom%E5%9F%BA%E7%A1%80_Document%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-06-05T04:10:20.000Z</published>
    <updated>2021-06-05T06:08:48.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>Document 类型是 JavaScript 中表示文档节点的类型。</li><li>在浏览器中，文档对象 document 是HTMLDocument 的实例 （HTMLDocument 继承 Document），表示整个HTML页面</li><li>document 是 window 对象的属性。</li></ol><p>特征：</p><ul><li>nodeType 等于 9；</li><li>nodeName 值为 ‘#document’ ；</li><li>nodeValue 值为 null；</li><li>parentNode 值为 null；</li><li>ownerDocument 值为 null；</li><li>子节点可以为DocumentType(最多一个)、Element(最多一个)、ProcessingInstruction 或 Comment 类型</li></ul><p>Document 类型可以表示 HTML 页面或其他 XML 文档，但最常用的还是通过HTMLDocument的实例取得 document对象。</p><p>document对象可以获取关于页面的信息以及操作其外观和底层结构。</p><h2 id="文档子节点"><a href="#文档子节点" class="headerlink" title="文档子节点"></a>文档子节点</h2><h3 id="documentElement"><a href="#documentElement" class="headerlink" title="documentElement"></a>documentElement</h3><p>documentElement 属性，始终指向HTML页面的 html 元素。虽然 document.childNodes 中始终有 html 元素，但使用 documentElement 属性可以更快更直接的访问该元素。</p><pre><code class="html">&lt;html&gt;  &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>documentElement、firstChild 和 childNodes[0]</p><pre><code class="js">let html = document.documentElement; //取得对&lt;html&gt;的引用alert(html === document.childNodes[0]);  //truealert(html === document.firstChild);  //true</code></pre><h3 id="body"><a href="#body" class="headerlink" title="body"></a>body</h3><p>作为HTMLDocument 的实例，document 对象还有一个body 属性，直接指向 body 元素。</p><pre><code>let body = document.body;</code></pre><p>所有主流浏览器都支持  document.documentElement 和 document.body</p><h3 id="doctype"><a href="#doctype" class="headerlink" title="doctype"></a>doctype</h3><p>Document 类型另一种可能的子节点是 DocumentType。</p><pre><code>&lt;!doctype&gt;标签是文档中独立的部分，其信息可以通过 doctype 属性来访问let doctype = document.doctype; //取得对&lt;!doctype&gt;的引用</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>html 元素外的注释也是文档的子节点，它们的类型是Comment。但是浏览器不同实现不同，这些注释不一定被识别，或者表现不一致。</p><p>这个页面有3个子节点：注释、html元素、注释，但是实际上不同浏览器可能会不一样</p><pre><code class="html">&lt;!-- 第一条注释 --&gt;&lt;html&gt;  &lt;body&gt;      &lt;/body&gt;&lt;/html&gt;&lt;!-- 第二条注释 --&gt;</code></pre><p>另外，一般来说 appendChild()、removeChild()和 replaceChild() 方法不会用在 document 对象上。因为文档类型（如果存在）是只读的，而且只能有一个Element类型的子节点</p><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><ol><li>包含 title 元素中的文本，通常显示在浏览器窗口或标签页的标题栏。</li><li>通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。</li><li>不过，修改title属性并不会改变 title 元素</li></ol><pre><code>// 读取文档标题let originalTitle = document.title;// 修改文档标题document.title = &quot;New page title&quot;;</code></pre><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>URL包含当前页面完整的URL（地址栏中的URL）</p><pre><code>let url = document.URL;</code></pre><h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>domian 包含当前的域名</p><pre><code>let domain = document.domain;</code></pre><p>domain 可以设置，但是只能设置 URL 中包含的值。</p><pre><code>// 页面来自 p2p.wrox.comdocument.domain = &quot;wrox.com&quot;; //成功document.domain = &quot;aaa.com&quot;; //失败</code></pre><p>当页面中包含来自某个不同子域的窗格（frame）或内嵌窗格（iframe）时，设置document.domain是有用的。因为跨源通信存在安全隐患，所以不同子域的页面间无法通过JavaScript通信。此时只要将每个页面上的document.domain设置为相同的值，这些页面就可以访问对方的JavaScript对象了。</p><p>浏览器对domain属性设置只能放松不能收紧</p><h3 id="referrer"><a href="#referrer" class="headerlink" title="referrer"></a>referrer</h3><p>包含链接到当前页面的那个页面的URL，如果当前页面没有来源，则referrer属性包含空字符串</p><pre><code>let refferrer = document.referrer</code></pre><h2 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h2><h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h3><ol><li>接收一个参数，即要返回元素的ID，如果找到了则返回这个元素，如果没找到则返回null。</li><li>参数必须和元素在页面中的id属性值完全匹配，包括大小写。</li><li>如果页面存在多个具有相同ID的元素，则方法只返回文档中出现的第一个元素</li></ol><pre><code>&lt;div id=&quot;myDiv&quot;&gt;hello&lt;/div&gt;let div = document.getElementById(&quot;myDiv&quot;) // 取得对这个&lt;div&gt;元素的引用</code></pre><h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName()"></a>getElementsByTagName()</h3><ol><li>接收一个参数，要获取元素的标签名，返回包含零个或多个元素的 NodeList</li><li>在HTML文档中，这个方法返回一个HTMLCollection对象。考虑到两者都是“实时”列表，HTMLCollection 与 NodeLIst 是很相似的。</li><li>可以通过传入 * 获取文档的所有元素</li></ol><pre><code>let images = document.getElementsByTagName(&quot;img&quot;);</code></pre><p>这里把返回的 HTMLCollection 对象保存在了变量 images 中，与NodeList一样，也可以使用 中括号 或 item() 方法从HTMLCollection 取得特定的元素。</p><pre><code>alert(images.length);alert(images[0].src);alert(images.item(0).src);</code></pre><p>HTMLCollection 对象还有一个额外的方法 namedItem()，可通过标签的 name 属性取得某一项的引用。</p><pre><code>&lt;img src=&quot;my.jpg&quot; name=&quot;myImage&quot;&gt;</code></pre><pre><code>let images = document.getElementsByTagName(&quot;img&quot;);let myImage1 = images.namedItem(&quot;myImage&quot;);let myImage2 = images[&quot;myImage&quot;];</code></pre><h3 id="getElementByName"><a href="#getElementByName" class="headerlink" title="getElementByName()"></a>getElementByName()</h3><p>这个方法会返回具有给定 name 属性的所有元素，最常用于单选按钮</p><h2 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h2><ul><li>document.anchors：包含文档中所有带name属性的 a 元素</li><li>document.forms：包含文档中所有 from 元素</li><li>document.images：包含文档中中所有 img 元素</li><li>document.links：包含文档中所有带href属性的 a 元素</li></ul><h2 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h2><ul><li>write()</li><li>writeIn()</li><li>open()</li><li>close()</li></ul><p>该内容可参考以下文章：</p><p><a href="https://blog.csdn.net/m0_37589327/article/details/78992784">https://blog.csdn.net/m0_37589327/article/details/78992784</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Document 类型是 JavaScript 中表示文档节点的类型。&lt;/li&gt;
&lt;li&gt;在浏览器中，文档对象 document</summary>
      
    
    
    
    <category term="JavaScript高级程序设计笔记" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Dom" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/Dom/"/>
    
    
    <category term="JavaScript" scheme="https://dongpangp.github.io/tags/JavaScript/"/>
    
    <category term="Dom" scheme="https://dongpangp.github.io/tags/Dom/"/>
    
  </entry>
  
  <entry>
    <title>伪数组</title>
    <link href="https://dongpangp.github.io/2021/06/05/%E4%BC%AA%E6%95%B0%E7%BB%84/"/>
    <id>https://dongpangp.github.io/2021/06/05/%E4%BC%AA%E6%95%B0%E7%BB%84/</id>
    <published>2021-06-05T03:02:31.000Z</published>
    <updated>2021-06-05T03:15:57.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="伪数组的特点"><a href="#伪数组的特点" class="headerlink" title="伪数组的特点"></a>伪数组的特点</h2><ul><li>Object 对象</li><li>length 属性</li><li>数值下标属性</li><li>没有数组特别的方法：forEach() ，push()，pop()，splice()</li></ul><pre><code class="js">const obj = &#123;      0: tom,      1: jerry,      2: bob      length: 3&#125;</code></pre><h2 id="如何判断一个对象是否属于伪数组"><a href="#如何判断一个对象是否属于伪数组" class="headerlink" title="如何判断一个对象是否属于伪数组"></a>如何判断一个对象是否属于伪数组</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><pre><code>console.log(Array.isArray(obj)) // false;</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><pre><code>console.log(obj instanceof Array) //false</code></pre><h2 id="常见的伪数组"><a href="#常见的伪数组" class="headerlink" title="常见的伪数组"></a>常见的伪数组</h2><ol><li>jQuery 对象（比如 $(“div”)）</li><li>函数内部的arguments</li><li>DOM中 NodeList对象</li></ol><h2 id="将伪数组转换成数组"><a href="#将伪数组转换成数组" class="headerlink" title="将伪数组转换成数组"></a>将伪数组转换成数组</h2><p>可以使用Array.prototype.slice.call() 将数组转化为真正的Array对象</p><pre><code>const arr = Array.prototype.slice.call(obj);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;伪数组的特点&quot;&gt;&lt;a href=&quot;#伪数组的特点&quot; class=&quot;headerlink&quot; title=&quot;伪数组的特点&quot;&gt;&lt;/a&gt;伪数组的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Object 对象&lt;/li&gt;
&lt;li&gt;length 属性&lt;/li&gt;
&lt;li&gt;数值下标属性&lt;/li</summary>
      
    
    
    
    <category term="JavaScript高级程序设计笔记" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    
    <category term="对象" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="JavaScript" scheme="https://dongpangp.github.io/tags/JavaScript/"/>
    
    <category term="Object" scheme="https://dongpangp.github.io/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>jQuery</title>
    <link href="https://dongpangp.github.io/2021/06/05/jQuery/"/>
    <id>https://dongpangp.github.io/2021/06/05/jQuery/</id>
    <published>2021-06-05T01:38:35.000Z</published>
    <updated>2021-06-16T05:18:33.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何使用jQuery？"><a href="#如何使用jQuery？" class="headerlink" title="如何使用jQuery？"></a>如何使用jQuery？</h2><h3 id="下载jQuery库"><a href="#下载jQuery库" class="headerlink" title="下载jQuery库"></a>下载jQuery库</h3><p>下载地址：<a href="http://code.jquery.com/">http://code.jquery.com/</a></p><h3 id="引入下载的jQuery库"><a href="#引入下载的jQuery库" class="headerlink" title="引入下载的jQuery库"></a>引入下载的jQuery库</h3><pre><code>&lt;script src=&quot;code/js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="编写jQuery代码"><a href="#编写jQuery代码" class="headerlink" title="编写jQuery代码"></a>编写jQuery代码</h3><pre><code>// 原生JS的固定写法window.onload = function(ev)&#123;&#125;// jQuery的固定写法$(document).ready(function()&#123;   ...&#125;);</code></pre><h3 id="jQuery版本区别"><a href="#jQuery版本区别" class="headerlink" title="jQuery版本区别"></a>jQuery版本区别</h3><p>1.x ：兼容ie678，但相对其他版本文件较大，官方只做BUG维护，功能不再新增，最终版本：1.12.4（2016年5月20日）</p><p>2.x：不兼容ie678，相对1.x文件较小，官方只做BUG维护，功能不再新增，最终版本：2.2.4（2016年5月20日）</p><p>3.x：不兼容ie678，只支持最新的浏览器，很多老的jQuery插件不支持这个版本，相对1.x文件较小，提供不包含ajax/动画API版本</p><h2 id="jQuery入口函数"><a href="#jQuery入口函数" class="headerlink" title="jQuery入口函数"></a>jQuery入口函数</h2><h3 id="jQuery与原生js加载模式的区别"><a href="#jQuery与原生js加载模式的区别" class="headerlink" title="jQuery与原生js加载模式的区别"></a>jQuery与原生js加载模式的区别</h3><h4 id="加载内容不同"><a href="#加载内容不同" class="headerlink" title="加载内容不同"></a>加载内容不同</h4><p>​    原生js会在dom原生与图片内容都加载后执行；</p><p>​    jQuery会在dom元素加载后执行，不会等待图片加载。</p><h4 id="多个入口文件时执行方式不同"><a href="#多个入口文件时执行方式不同" class="headerlink" title="多个入口文件时执行方式不同"></a>多个入口文件时执行方式不同</h4><p>​    原生js只执行最后一个入口文件的内容，即后面的会覆盖前面的；</p><p>​    jQuery多个都执行，前面的执行完才执行后面的</p><h3 id="jQuery入口函数的写法"><a href="#jQuery入口函数的写法" class="headerlink" title="jQuery入口函数的写法"></a>jQuery入口函数的写法</h3><pre><code>$(document).ready(function()&#123;    ...&#125;);jQuery(document).ready(function()&#123;    ...&#125;);$(function()&#123; ...&#125;);</code></pre><h3 id="jQuery冲突问题"><a href="#jQuery冲突问题" class="headerlink" title="jQuery冲突问题"></a>jQuery冲突问题</h3><p>​    当引入多个js文件后，发生 $ 符号重复冲突时</p><p>​    解决方法1：释放 $ 的使用权</p><p>​    注意点：释放操作必须在编写其他 jQuery 代码之前；释放之后不能再使用 $，改为使用 jQuery</p><pre><code>jQuery.noConflict();  //释放操作jQuery(function()&#123;    alert(&#39;hello world&#39;);&#125;);</code></pre><p>​    解决方法2：自定义一个访问符号</p><pre><code>var mmp = jQuery.noConflict();mmp(function()&#123;    alert(&#39;hello mmp&#39;);&#125;);</code></pre><h2 id="jQuery核心函数"><a href="#jQuery核心函数" class="headerlink" title="jQuery核心函数"></a>jQuery核心函数</h2><p>$(); 就代表调用 jQuery 的核心函数</p><pre><code class="js">// 1、接收一个函数$(function ()&#123;  //2、接收一个字符串  //2.1、接收一个字符串选择器,返回一个jQuery对象，对象中保存了找到的DOM对象  var $box1 = $(&quot;.box1&quot;);  var $box2 = $(&quot;#box2&quot;);  //2.2、接收一个字符串代码片段,返回一个jQuery对象,对象保存了DOM元素  var $p = $(&quot;&lt;p&gt;我是段落&lt;/p&gt;&quot;);  $box1.append($p);  // 3、接收一个DOM元素，返回一个jQuery对象  var span = document.getElementByTagName(&quot;span&quot;)[0];  var $span = $(span);  console.log($span);&#125;);</code></pre><h2 id="jQuery-静态方法"><a href="#jQuery-静态方法" class="headerlink" title="jQuery 静态方法"></a>jQuery 静态方法</h2><h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><p>用于遍历指定的对象和数组，即可以遍历伪数组</p><p>each方法 遍历谁就返回谁</p><pre><code>$.each( object,callback );// 举例 index 索引 value 值$(function()&#123;    $.each([23,32],function(index,value)&#123;        alert(index+&#39;:&#39;+value);    &#125;)&#125;);</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>描述：将一个数组中的所有元素转换到另一个数组中</p><p>jQuery.map(array,callback(elementOfArray,indexInArray))</p><p>array ：数组 </p><p>callback(elementOfArray,indexInArray)：处理每一个元素的函数。第一个参数是数组元素，第二个参数是该元素的索引值。该函数可以返回任何值，在函数内部，this将是全局window对象</p><p>jQuery.map(arrayOrObject,callback(value,indexOrKey))</p><p>arrayOrObject：待转换数组或对象</p><p>callback(value,indexOrKey)：处理每一个元素的函数。第一个参数是数组中或对象的值，第二个参数就是该元素在数组中的索引值或该对象的键。该函数可以返回任何值，该返回值会被添加到数组中。若返回时数组，则会将该数组中的元素添加到最终的结果数组中，在函数内部，this将是全局window对象</p><p><strong>在jQuery 1.6之前，</strong><code>$.map()</code>只支持遍历<em>数组和类似数组的对象</em> 。<strong>在jQuery 1.6</strong>也支持遍历对象。</p><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>去除字符串前后空格</p><pre><code>var str = &quot;  ls  &quot;;var res = $.trim(str);console.log(&quot;---&quot;+str+&quot;---&quot;);console.log(&quot;---&quot;+res+&quot;---&quot;);</code></pre><h3 id="isWindow"><a href="#isWindow" class="headerlink" title="isWindow"></a>isWindow</h3><p>判断传入的对象是否是window对象</p><p>返回值：true/false</p><h3 id="isArray"><a href="#isArray" class="headerlink" title="isArray"></a>isArray</h3><p>判断传入的对象是否为数组</p><p>返回值：true/false</p><h3 id="isFunction"><a href="#isFunction" class="headerlink" title="isFunction"></a>isFunction</h3><p>判断传入的对象是否为函数</p><p>返回值：true/false</p><p>jQuery是一个函数</p><h3 id="holdReady"><a href="#holdReady" class="headerlink" title="holdReady"></a>holdReady</h3><p>$.holdReady(true);  作用：暂停ready执行</p><p>$.holdReady(false); 作用：恢复执行</p><pre><code>$.holdReady(true); $(document).ready(function()&#123;    alert(&quot;ready&quot;);&#125;);</code></pre><h2 id="jQuery内容选择器"><a href="#jQuery内容选择器" class="headerlink" title="jQuery内容选择器"></a>jQuery内容选择器</h2><pre><code class="html">&lt;div&gt;&lt;/div&gt;&lt;div&gt;  我是div&lt;/div&gt;&lt;div&gt;  &lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><h3 id="empty"><a href="#empty" class="headerlink" title=":empty"></a>:empty</h3><p>作用：找到既没有文本内容也没有子元素的指定元素</p><pre><code>var $div = $(&quot;div:empty&quot;);</code></pre><h3 id="parent"><a href="#parent" class="headerlink" title=":parent"></a>:parent</h3><p>作用：找到有文本内容或有子元素的指定元素</p><pre><code>var $div = $(&quot;div:parent&quot;);</code></pre><h3 id="contains"><a href="#contains" class="headerlink" title=":contains"></a>:contains</h3><p>作用：找到包含指定文本内容的指定元素</p><pre><code>var $div = $(&quot;div:contains(&#39;我是div&#39;)&quot;);</code></pre><h3 id="has"><a href="#has" class="headerlink" title=":has"></a>:has</h3><p>作用：找到包含指定子元素的指定元素</p><pre><code>var $div = $(&quot;div:has(&#39;span&#39;)&quot;);</code></pre><h2 id="属性和属性节点"><a href="#属性和属性节点" class="headerlink" title="属性和属性节点"></a>属性和属性节点</h2><h3 id="attr-name-pro-key-val-fn"><a href="#attr-name-pro-key-val-fn" class="headerlink" title="attr(name|pro|key,val|fn)"></a>attr(name|pro|key,val|fn)</h3><p>获取或者设置属性节点的值</p><p>如果传递一个参数，代表获取属性节点的值</p><p>如果传递两个参数，代表设置属性节点的值</p><p>注意：</p><ul><li>获取，无论找到多少个元素，都只会返回第一个元素指定的属性节点的值</li><li>设置，找到多少个元素就会设置多少个元素</li><li>设置，如果设置的属性节点不存在，那么系统会自动新增</li></ul><pre><code>console.log($(&quot;span&quot;).attr(&quot;class&quot;));$(&quot;span&quot;).attr(&quot;class&quot;,&quot;box&quot;);$(&quot;span&quot;).attr(&quot;abc&quot;,&quot;123&quot;);</code></pre><h3 id="removeAttr-name"><a href="#removeAttr-name" class="headerlink" title="removeAttr(name)"></a>removeAttr(name)</h3><p>删除属性节点</p><p>注意：会删除所有找到元素指定的属性节点</p><pre><code>// 删除所有span中包含的 class$(&quot;span&quot;).removeAttr(&quot;class&quot;);</code></pre><h3 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h3><h3 id="removeProp"><a href="#removeProp" class="headerlink" title="removeProp"></a>removeProp</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>官方推荐在操作属性节点时，具有 true 和 false 两个属性的属性节点，如checked、selected或者disabled 使用prop()，其他的使用 attr()</p><pre><code>$(function()&#123;    var btn = document.getElementsByTagName(&quot;button&quot;)[0];    btn.onclick = function()&#123;        var input = document.getElementsByTagName(&quot;input&quot;)[0];        var text = input.value;        $(&quot;img&quot;).attr(&quot;src&quot;,text);        //$(&quot;img&quot;).prop(&quot;src&quot;,text); //效果一样    &#125;&#125;)</code></pre><h2 id="JQuery操作CSS类的相关方法"><a href="#JQuery操作CSS类的相关方法" class="headerlink" title="JQuery操作CSS类的相关方法"></a>JQuery操作CSS类的相关方法</h2><h3 id="addClass-class-fn"><a href="#addClass-class-fn" class="headerlink" title="addClass(class|fn)"></a>addClass(class|fn)</h3><p>添加类，如果要添加多个，多个类名之间用空格隔开即可。</p><pre><code>$(function()&#123;    var btns = document.getElementsByTagName(&quot;button&quot;);    btns[0].onclick = function()&#123;        $(&quot;div&quot;).addClass(&quot;class1 class2&quot;);    &#125;&#125;)</code></pre><h3 id="removeClass"><a href="#removeClass" class="headerlink" title="removeClass"></a>removeClass</h3><p>删除类，如果要删除多个，多个类名之间用空格隔开即可</p><h3 id="toggleClass"><a href="#toggleClass" class="headerlink" title="toggleClass"></a>toggleClass</h3><p>切换类，有就删除，没有就添加</p><h2 id="JQuery-文本值相关的方法"><a href="#JQuery-文本值相关的方法" class="headerlink" title="JQuery 文本值相关的方法"></a>JQuery 文本值相关的方法</h2><h3 id="html-val-fn"><a href="#html-val-fn" class="headerlink" title="html([val|fn])"></a>html([val|fn])</h3><h3 id="text-val-fn"><a href="#text-val-fn" class="headerlink" title="text([val|fn])"></a>text([val|fn])</h3><h3 id="val-val-fn-arr"><a href="#val-val-fn-arr" class="headerlink" title="val([val|fn|arr])"></a>val([val|fn|arr])</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何使用jQuery？&quot;&gt;&lt;a href=&quot;#如何使用jQuery？&quot; class=&quot;headerlink&quot; title=&quot;如何使用jQuery？&quot;&gt;&lt;/a&gt;如何使用jQuery？&lt;/h2&gt;&lt;h3 id=&quot;下载jQuery库&quot;&gt;&lt;a href=&quot;#下载jQuery</summary>
      
    
    
    
    <category term="jQuery" scheme="https://dongpangp.github.io/categories/jQuery/"/>
    
    
    <category term="jQuery" scheme="https://dongpangp.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>dom基础_节点Node类型</title>
    <link href="https://dongpangp.github.io/2021/06/04/dom%E5%9F%BA%E7%A1%80_%E8%8A%82%E7%82%B9Node%E7%B1%BB%E5%9E%8B/"/>
    <id>https://dongpangp.github.io/2021/06/04/dom%E5%9F%BA%E7%A1%80_%E8%8A%82%E7%82%B9Node%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-06-04T04:41:48.000Z</published>
    <updated>2021-06-05T04:10:54.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM表示由多层节点构成的文档，通过它可以添加、删除、修改页面各个部分。</p><p>DOM Level 1 在1998年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。</p><p><span style="color: red;font-size:20px">注意</span>    IE8 及更低版本中的 DOM 是通过 COM 对象实现的。 这意味着这些版本的IE中， DOM 对象跟原生 JavaScript 对象具有不同的行为和功能。</p><h2 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h2><p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由<span style="color:yellow">节点</span>构成的层级结构 </p><p>节点分很多类型，每种类型对应着文档中不同的信息和（或）标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系</p><p>例如：</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Sample Page&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p&gt; hello world!&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>层级结构：</p><p><img src="https://raw.githubusercontent.com/DongPangP/myImages/main/Document.png"></p><p>document 节点是每个文档的根节点</p><p>根节点唯一的子节点是 html 元素，被称为 文档元素。 文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内，每个文档只能有一个文档元素。</p><p>HTML 中每段标记都可以表示为这个树形结构中的一个节点。</p><p>元素节点表示HTML元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。</p><p>DOM中总共有12种节点类型，这些类型都继承一种基本类型</p><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>DOM Level 1 描述了名为Node的接口，这个接口是所有 DOM 节点类型必须实现的。</p><p>Node接口在JavaScript中被实现为Node类型，在除IE之外的所有浏览器中都可以直接访问这个类型。</p><p>在JavaScript中，所有节点类型都继承Node类型，因此所有类型都共享相同的基本属性和方法。</p><p>每个节点都有nodeType 属性，表示该节点的类型。节点类型由定义在Node类型上的12个数值常量表示：</p><ul><li>Node.ELEMENT_NODE(1)</li><li>Node.ATTRIBUTE_NODE(2)</li><li>Node.TEXT_NODE(3)</li><li>Node.CDATA_SECTION_NODE(4)</li><li>Node.ENTITY_REFERENCE_NODE(5)</li><li>Node.ENTITY_NODE(6)</li><li>Node.PROCESSING_INSTRUCTION_NODE(7)</li><li>Node.COMMENT_NODE(8)</li><li>Node.DOCUMENT_NODE(9)</li><li>Node.DOCUMENT_TYPE_NODE(10)</li><li>Node.DOCUMENT_FRAGMENT_NODE(11)</li><li>Node.NOTATION_NODE(12)</li></ul><p>节点类型可通过这些常量来比较确定，比如：</p><pre><code>// 比较someNode.nodeType 与 Node.ElEMENT_NODE常量if(someNode.nodeType === Node.ElEMENT_NODE)&#123;    alert(&quot;Node is an element&quot;);&#125;</code></pre><p><span style="color: red;font-size:20px">注意</span>    浏览器并不支持所有节点类型，最常用的是元素节点和文本节点</p><h4 id="nodeName-和-nodeValue"><a href="#nodeName-和-nodeValue" class="headerlink" title="nodeName 和 nodeValue"></a>nodeName 和 nodeValue</h4><p>这两个值保存了节点信息，且取决于节点信息。</p><p>首先检查节点类型</p><pre><code>// 判断节点是否为元素if(someNode.nodeType === 1)&#123;    value = someNode.nodeName;&#125;//对元素而言，nodeName始终等于元素的标签名，而nodeValue则始终为null</code></pre><h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>文档中所有节点和其他节点都有关系，相当于族谱。</p><p>每个节点都有一个childNodes属性，其中包含一个NodeList的实例</p><p><span style="color:yellow">NodeList</span> 是一个类数组对象，用于存储可以按位置存取的有序节点。注意：NodeList 并不是Array的实例，但可以使用中括号访问它的值，而且它也有length属性。NodeList对象独特的地方在于，它其实是一个对DOM结构的查询，因此DOM结构的变化会自动地在NodeLIst反映出来。 NodeList是实时的活动对象，而不是第一次访问所获得内容的快照。</p><p>使用<span style="color:yellow"> Array.prototype.slice()</span> 可以把NodeList对象转换为数组。</p><pre><code>let arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0);</code></pre><p>当然，也可以使用 ES6 的 Array.from() 静态方法</p><pre><code>let arrayOfNodes = Array.from(someNode.childNodes);</code></pre><p><img src="https://raw.githubusercontent.com/DongPangP/myImages/main/image-20210604151238225.png" alt="image-20210604151238225"></p><ol><li>每个节点都有一个parentNode属性，指向DOM树中的父元素。childNodes中的所有节点都有同一个父元素，因此它们的parentNode属性指向同一个节点。</li><li>childNodes列表中的每个节点都是同一个列表中其他节点的同胞节点。使用 previousSibling 和 nextSibling 可以在这个列表的节点中进行导航。</li><li>这个列表的第一个节点的 previousSibling 属性是null，最后一个节点的 nextSibling 属性也是 null</li><li>firstChild 和 lastChild 分别指向childNodes的第一个和最后一个，如果只有一个则指向同一个，如果没有则均为null</li><li>可以使用 hasChildNodes() ,返回true，则节点有一个或多个子节点</li><li>最后还有一个所有节点都共享的关系。ownerDocument 属性是一个指向代表整个文档的文档节点的指针。所有节点都被创建它们（或自己所在）的文档所拥有，因为一个节点不可能存在于两个或多个文档中。</li></ol><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>因为所有关系指针都是只读的，所以DOM提供了一些操作节点的方法：</p><p>appendChild() ：</p><ul><li>​    用于在childNodes 列表<span style="color:yellow">末尾</span>添加节点。</li><li>​    添加新的节点会更新相关的关系指针，包括父节点和之前最后一个子节点。</li><li>​    返回新添加的节点。</li><li>​    如果把已经存在的节点给appenChild()，则调用一次就会出现在末尾。</li></ul><pre><code>let returnedNode = someNode.appendChild(someNode.firstChild);alert(returnedNode == someNode.lastChild);  // truealert(returnedNode == someNode.firstChild); // false</code></pre><p>insertBefore() ：把节点放到childNodes中特定位置而不是末尾</p><pre><code>// 作为最后一个子节点插入returnedNode = someNode.insertBefore(newNode,null);// 作为新的第一个子节点插入returnedNode = someNode.insertBefore(newNode,someNode.firstChild);// 插入到最后一个子节点前面returnedNode = someNode.insertBefore(newNode,someNode.lastChild);</code></pre><p>replaceChild() ：要插入的节点和要替换的节点 ，要替换的节点会被返回并从文档树中移除</p><pre><code>// 替换第一个子节点let returnedNode = someNode.replaceChild(newNode,someNode.firstChild);// 替换最后一个子节点returnedNode = someNode.replaceChild(newNode,someNode.lastChild);</code></pre><p>removeChild() ：移除节点，要删除的节点会被返回并从文档树中移除</p><pre><code>// 删除第一个子节点let formerFirstChild = someNode.removeChild(someNode.firstChild);</code></pre><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>cloneNode()</p><p>该方法接收一个布尔值额。如果传入true，会进行深复制，即复制节点及整个子DOM树；如果传入false，则只会复制调用该方法的节点。</p><p>复制返回的节点属于文档所有，但尚未指定父节点，所以被称为孤儿节点（orphan）</p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;item 1&lt;/li&gt;  &lt;li&gt;item 2&lt;/li&gt;  &lt;li&gt;item 3&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="js">let deepList = myList.cloneNode(true);alert(deepList.childNodes.length) // 3(IE9之前的版本 或 7 其他浏览器)let shallowList = myList.cloneNode(false);alert(shallowList.childNodes.length) //0</code></pre><p>这个例子中，deepList 保存myList的副本。这意味着 deepList 有3个列表项，每个列表项又各自包含文本。 变量 shallowList 则保存着 myList 的浅副本，因此没有子节点</p><p>注意： cloneNode() 方法不会复制添加到DOM节点的JavaScript属性，比如事件处理程序。这个方法只复制HTML属性，以及可选的复制子节点。除此之外则一概不会复制。IE在很长时间内会复制事件处理程序，这是个bug，所以推荐在复制前先删除事件处理程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM表示由多层节点构成的文档，</summary>
      
    
    
    
    <category term="JavaScript高级程序设计笔记" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Dom" scheme="https://dongpangp.github.io/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/Dom/"/>
    
    
    <category term="JavaScript" scheme="https://dongpangp.github.io/tags/JavaScript/"/>
    
    <category term="Dom" scheme="https://dongpangp.github.io/tags/Dom/"/>
    
  </entry>
  
  <entry>
    <title>前端Excel下载</title>
    <link href="https://dongpangp.github.io/2021/06/03/%E5%89%8D%E7%AB%AFExcel%E4%B8%8B%E8%BD%BD/"/>
    <id>https://dongpangp.github.io/2021/06/03/%E5%89%8D%E7%AB%AFExcel%E4%B8%8B%E8%BD%BD/</id>
    <published>2021-06-03T07:32:24.000Z</published>
    <updated>2021-06-03T08:36:31.434Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color:red;font-size: 20px">本文借鉴</span> <a href="https://juejin.cn/post/6844903880413675527">纯前端用XLSX库导出excel，可含多个sheet (juejin.cn)</a></p><h2 id="导出逻辑"><a href="#导出逻辑" class="headerlink" title="导出逻辑"></a>导出逻辑</h2><ul><li><p>excel整个表格专业名词是<span style="color:yellow"> workbook</span>，里面每张表格是 <span style="color:yellow">sheet</span></p></li><li><p>页面引入 xlsx 的库 ，<a href="https://unpkg.com/xlsx/dist/xlsx.core.min.js">https://unpkg.com/xlsx/dist/xlsx.core.min.js</a></p></li><li><p>vue中引入xlsx的库</p><pre><code>1、npm install xlsx 2、import XLSX from &#39;xlsx&#39;</code></pre></li><li><p>把数据生成<span style="color:yellow">sheet</span></p><pre><code>var sheet = XLSX.utils.json_to_sheet(jsonData)/* json_to_sheet：将由对象组成的数组转换成sheet   aoa_to_sheet：将由二维数组转换成sheet   table_to_sheet：将table的dom直接转成sheet*/</code></pre></li><li><p>创建虚拟的 <span style="color:yellow">workbook</span></p><pre><code>const wb = XLSX.utils.book_new()</code></pre></li><li><p>把<span style="color:yellow">sheet</span>添加到<span style="color:yellow">workbook</span>里</p><pre><code>XLSX.utils.book_append_sheet(wb, sheet, &quot;这里是sheetName&quot;);</code></pre></li><li><p>把 <span style="color:yellow">workbook</span>转成<span style="color:yellow">blob</span></p><pre><code>const blob = workbook2blob(wb);//看下面的js代码</code></pre></li><li><p>利用a标签和createObjectURl实现下载功能</p><pre><code>openDownloadDialog(blob,&#39;excel的标题.xlsx&#39;);</code></pre></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="js">/** * 生成表格 */import XLSX from &#39;xlsx&#39;;// 将workbook转换成blob对象function workbook2blob(data) &#123;  // 生成excel的配置项  const wopts = &#123;    // 要生成的文件类型    bookType: &#39;xlsx&#39;,    // 是否生成Shared String Table，    // 官方解释时，如果开启生成速度会降低，但在低版本IOS设备上有更好的兼容性    bookSST: false,    type: &#39;binary&#39;  &#125;  const wbout = XLSX.write(data, wopts);  // 将字符串转 ArrayBuffer  function s2ab(s) &#123;    const buf = new ArrayBuffer(s.length);    const view = new Uint8Array(buf);    for (let i = 0; i !== s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xff;    return buf;  &#125;  const blob = new Blob([s2ab(wbout)], &#123;    type: &#39;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;&#39;  &#125;);  return blob;&#125; // 将blob对象创建bloburl，然后用a标签实现弹出下载框 function openDownloadDialog(blob, fileName) &#123;  if (typeof blob === &#39;object&#39; &amp;&amp; blob instanceof Blob) &#123;    blob = URL.createObjectURL(blob); // 创建blob地址  &#125;  const aLink = document.createElement(&#39;a&#39;);  aLink.href = blob;  // HTML5新增的属性，指定保存文件名，可以不要后缀，注意，有时候 file:///模式下不会生效  aLink.download = fileName || &#39;&#39;;  let event;  if (window.MouseEvent) &#123;    event = new MouseEvent(&#39;click&#39;);  &#125; else &#123; //   移动端    event = document.createEvent(&#39;MouseEvents&#39;);    event.initMouseEvent(&#39;click&#39;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);  &#125;  aLink.dispatchEvent(event);&#125;export default&#123;  workbook2blob,  openDownloadDialog&#125;</code></pre><pre><code class="js"> /**  * 转换下载ip数据  */async generateAndDownload() &#123;  try&#123;    const info = await this.getIpInfoAll();        const data = info.data.response.data;        if(data.length &gt; 0) &#123;        const sheetData = [];        for(let i = 0, len = data.length; i &lt; len; i++) &#123;           for(let j = 0, len = this.Category.length; j &lt; len; j++) &#123;            if(data[i].EquipmentCategory === this.Category[j].value) &#123;              data[i].EquipmentCategory = this.Category[j].label;              break;            &#125;          &#125;          const obj = &#123;             名称: data[i].EquipmentName,             IP地址: data[i].IPaddr,             Mac地址: data[i].MacAddr,             类型: data[i].EquipmentCategory,             备注: data[i].Note           &#125;           sheetData.push(obj);         &#125;         const sheet = XLSX.utils.json_to_sheet(sheetData);         /* create a new blank workbook */         const wb = XLSX.utils.book_new();         XLSX.utils.book_append_sheet(wb, sheet, &#39;IP信息&#39;);      const workbookBlob = generate.workbook2blob(wb);         generate.openDownloadDialog(workbookBlob, &#39;IP信息&#39;);    &#125;catch(err)&#123;      this.$message.error(&#39;下载出错！&#39;);    &#125;    &#125;    &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;span style=&quot;color:red;font-size: 20px&quot;&gt;本文借鉴&lt;/span&gt; &lt;a href=&quot;https://juejin.cn/post/6844903880413675527&quot;&gt;纯前端用XLSX库导出excel，可含多个sheet (juej</summary>
      
    
    
    
    <category term="vue" scheme="https://dongpangp.github.io/categories/vue/"/>
    
    <category term="拓展" scheme="https://dongpangp.github.io/categories/vue/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="vue" scheme="https://dongpangp.github.io/tags/vue/"/>
    
    <category term="xlsx库" scheme="https://dongpangp.github.io/tags/xlsx%E5%BA%93/"/>
    
  </entry>
  
</feed>
